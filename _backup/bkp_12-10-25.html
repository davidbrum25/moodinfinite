<!DOCTYPE html>
<html lang="en" style="--bg-page: #0d0d0d; --bg-ui: rgba(35, 38, 51, 0.4); --bg-ui-hover: rgba(55, 58, 71, 0.5); --text-color: #e2e8f0; --text-color-light: #94a3b8; --text-color-strong: #ffffff; --border-color: rgba(255, 255, 255, 0.1); --switch-bg-checked: #429eff;">
<head>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Moodinfinite v0.7.3</title>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;700&family=Roboto:ital,wght@0,400;0,700;1,400;1,700&family=Playfair+Display:ital,wght@0,400;0,700;1,400;1,700&family=Source+Code+Pro:ital,wght@0,400;0,700;1,400;1,700&display=swap" rel="stylesheet">
	<link rel="icon" href="fav_icon_alternative.png" type="image/png">
    <style>
        /* CSS variables will be set dynamically by JavaScript */
        body {
            font-family: 'Inter', sans-serif;
            overflow: hidden;
            background-color: var(--bg-page);
            margin: 0;
            overscroll-behavior: none;
        }
        canvas {
            display: block;
            background-color: var(--bg-canvas);
            cursor: grab;
        }
        canvas.grabbing {
            cursor: grabbing;
        }
        canvas.eyedropper-active {
            cursor: crosshair;
        }
        #context-menu {
            position: absolute;
            z-index: 2100;
            background: var(--bg-ui);
            border: 1px solid var(--border-color);
            border-radius: 0.75rem;
            box-shadow: 0 8px 32px 0 rgba(0, 0, 0, 0.37);
            padding: 0.75rem;
            display: none;
            width: 240px;
            backdrop-filter: blur(16px);
            -webkit-backdrop-filter: blur(16px);
        }
        .menu-item {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 0.4rem 0.5rem;
            border-radius: 0.375rem;
            cursor: pointer;
            transition: background-color 0.2s;
        }
        .menu-item .text-red-500 {
            color: #ef4444;
            text-shadow: 0 1px 2px rgba(0, 0, 0, 0.4);
        }
        .menu-item:hover {
            background-color: var(--bg-ui-hover);
        }
        .menu-label {
            font-size: 0.875rem;
            color: var(--text-color);
        }
        .switch {
            position: relative;
            display: inline-block;
            width: 38px;
            height: 22px;
        }
        .switch input {
            opacity: 0;
            width: 0;
            height: 0;
        }
        .slider {
            position: absolute;
            cursor: pointer;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: var(--border-color);
            transition: .4s;
            border-radius: 22px;
        }
        .slider:before {
            position: absolute;
            content: "";
            height: 16px;
            width: 16px;
            left: 3px;
            bottom: 3px;
            background-color: white;
            transition: .4s;
            border-radius: 50%;
            box-shadow: 0 1px 3px rgba(0,0,0,0.3);
        }
        input:checked + .slider {
            background-color: var(--switch-bg-checked);
        }
        input:checked + .slider:before {
            transform: translateX(16px);
        }
        .tool-button {
            background-color: transparent;
            border: 1px solid transparent;
            border-radius: 0.5rem;
            padding: 0.5rem;
            cursor: pointer;
            transition: all 0.2s;
            color: var(--text-color);
        }
        .tool-button:hover {
            background-color: var(--bg-ui-hover);
        }
        .tool-button:disabled {
            opacity: 0.4;
            cursor: not-allowed;
            background-color: var(--bg-ui);
        }
        .tool-button.active {
            background-color: var(--bg-ui-hover);
            color: var(--switch-bg-checked);
        }
        #top-bar {
            position: absolute;
            top: 1rem;
            left: 50%;
            transform: translateX(-50%);
            z-index: 50;
            display: flex;
            gap: 0.5rem;
            background: var(--bg-ui);
            padding: 0.5rem;
            border-radius: 0.75rem;
            box-shadow: 0 8px 32px 0 rgba(0, 0, 0, 0.37);
            border: 1px solid var(--border-color);
            backdrop-filter: blur(16px);
            -webkit-backdrop-filter: blur(16px);
            align-items: center;
        }
        #left-bar {
            position: absolute;
            top: 50%;
            left: 1rem;
            transform: translateY(-50%);
            z-index: 50;
            background: var(--bg-ui);
            padding: 0.5rem;
            border-radius: 0.75rem;
            box-shadow: 0 8px 32px 0 rgba(0, 0, 0, 0.37);
            display: flex;
            flex-direction: column;
            gap: 0.5rem;
            border: 1px solid var(--border-color);
            backdrop-filter: blur(16px);
            -webkit-backdrop-filter: blur(16px);
        }
        .separator {
            height: 1px;
            background-color: var(--border-color);
            margin: 0.25rem 0.25rem;
        }
        .slider-input {
            -webkit-appearance: none;
            appearance: none;
            width: 100%;
            flex-grow: 1;
            height: 8px;
            background: var(--border-color);
            border-radius: 9999px;
            cursor: pointer;
        }
        .slider-input::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 1rem;
            height: 1rem;
            background: var(--switch-bg-checked);
            cursor: pointer;
            border-radius: 50%;
        }
        .slider-value-box {
            background-color: var(--bg-ui-hover);
            color: var(--text-color);
            font-size: 0.75rem;
            padding: 0.25rem 0.5rem;
            border-radius: 0.375rem;
            min-width: 50px;
            text-align: center;
        }
        .color-picker-input {
            -webkit-appearance: none;
            -moz-appearance: none;
            appearance: none;
            width: 2rem;
            height: 2rem;
            background-color: transparent;
            border: none;
            cursor: pointer;
            padding: 0;
            border-radius: 0.375rem;
            overflow: hidden;
        }
        .color-picker-input::-webkit-color-swatch {
            border-radius: 0.375rem;
            border: 1px solid var(--border-color);
        }
        .color-picker-input::-moz-color-swatch {
            border-radius: 0.375rem;
            border: 1px solid var(--border-color);
        }

        #selection-toolbar {
            position: absolute;
            z-index: 1001;
            background: var(--bg-ui);
            padding: 0.35rem;
            border-radius: 0.75rem;
            box-shadow: 0 8px 32px 0 rgba(0, 0, 0, 0.37);
            display: none;
            gap: 0.35rem;
            border: 1px solid var(--border-color);
            transform: translate(-50%, 10px); /* Position adjustment */
            backdrop-filter: blur(16px);
            -webkit-backdrop-filter: blur(16px);
        }
        .selection-tool-btn {
            background-color: transparent;
            border: none;
            border-radius: 0.375rem;
            padding: 0.4rem;
            cursor: pointer;
            color: var(--text-color);
            transition: all 0.2s;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        .selection-tool-btn:hover {
            background-color: var(--bg-ui-hover);
        }
        .selection-tool-btn.active {
            background-color: var(--bg-ui-hover);
            color: var(--switch-bg-checked);
        }
        .selection-tool-btn.pinned {
            color: #f59e0b; /* Amber color for pinned */
        }
        .selection-tool-btn .text-red-500 {
             color: #ef4444;
        }
        .selection-tool-select {
            background-color: transparent;
            border: none;
            border-radius: 0.375rem;
            padding: 0.4rem;
            cursor: pointer;
            color: var(--text-color);
            font-family: 'Inter', sans-serif;
            font-size: 0.8rem;
            outline: none;
            -webkit-appearance: none;
            -moz-appearance: none;
            appearance: none;
        }
        .selection-tool-select:hover {
            background-color: var(--bg-ui-hover);
        }
        .selection-tool-select option {
            background-color: var(--bg-ui);
            color: var(--text-color);
            font-weight: normal;
            font-style: normal;
        }
        #text-tools-container, #grid-tools-container {
            display: none; 
            align-items: center; 
            gap: 0.35rem; 
            border-right: 1px solid var(--border-color); 
            padding-right: 0.35rem; 
            margin-right: 0.35rem;
        }
        #grid-tools-container .grid-input {
            background-color: transparent;
            border: 1px solid transparent;
            color: var(--text-color);
            width: 45px;
            font-size: 0.8rem;
            border-radius: 0.25rem;
            padding: 0.2rem;
            text-align: center;
        }
         #grid-tools-container .grid-input:hover {
             background-color: var(--bg-ui-hover);
         }
        #text-editor {
            position: absolute;
            z-index: 1002;
            border: none;
            outline: none;
            padding: 10px;
            margin: 0;
            font-family: 'Inter', sans-serif;
            resize: none;
            overflow: hidden;
            box-sizing: border-box;
            line-height: 1.4;
        }
        #box-color-picker-container {
            position: absolute;
            z-index: 1001;
            display: none;
        }
        #box-color-picker {
             width: 24px;
             height: 24px;
             padding: 2px;
             border-radius: 50%;
             background-color: var(--bg-ui);
             border: 1px solid var(--border-color);
             box-shadow: 0 2px 4px rgba(0,0,0,0.2);
        }
         .flex { display: flex; }
        .items-center { align-items: center; }
        .gap-2 { gap: 0.5rem; }
        .border-t { border-top-width: 1px; }
        .my-2 { margin-top: 0.5rem; margin-bottom: 0.5rem; }

        /* Confirmation Modal Styles */
        #confirmation-modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0,0,0,0.5);
            z-index: 2000;
            display: none; /* Initially hidden */
            align-items: center;
            justify-content: center;
            backdrop-filter: blur(4px);
            -webkit-backdrop-filter: blur(4px);
        }
        #confirmation-modal {
            background: var(--bg-ui);
            color: var(--text-color);
            padding: 1.5rem 2rem;
            border-radius: 1rem;
            border: 1px solid var(--border-color);
            box-shadow: 0 8px 32px 0 rgba(0, 0, 0, 0.37);
            text-align: center;
            backdrop-filter: blur(16px);
            -webkit-backdrop-filter: blur(16px);
        }
        #confirmation-modal h2 {
            margin: 0 0 0.5rem 0;
            font-size: 1.125rem;
            color: var(--text-color-strong);
        }
        #confirmation-modal p {
            margin: 0 0 1.5rem 0;
            font-size: 0.875rem;
            color: var(--text-color-light);
            max-width: 280px;
        }
        .modal-buttons {
            display: flex;
            gap: 0.75rem;
            justify-content: center;
        }
        .modal-button {
            padding: 0.5rem 1rem;
            border: 1px solid transparent;
            border-radius: 0.375rem;
            font-size: 0.875rem;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.2s ease;
        }
        .modal-button.confirm {
            background-color: #ef4444; /* Red */
            color: white;
            border-color: transparent;
        }
        .modal-button.confirm:hover {
            background-color: #dc2626;
        }
        .modal-button.cancel {
            background-color: var(--bg-ui-hover);
            color: var(--text-color);
            border-color: var(--border-color);
        }
        .modal-button.cancel:hover {
            opacity: 0.8;
        }

        #project-name-input {
            background: transparent;
            border: none;
            color: var(--text-color);
            font-size: 0.8rem;
            font-weight: 900;
            padding: 0.5rem;
            width: 160px;
            text-align: right;
            border-radius: 0.375rem;
            outline: none;
            transition: all 0.2s;
        }
        #project-name-input:hover {
            background-color: var(--bg-ui-hover);
        }
        #project-name-input:focus {
            color: var(--text-color-strong);
            background-color: var(--bg-ui-hover);
            box-shadow: 0 0 0 1px var(--switch-bg-checked);
        }

        /* Palette Panel Styles */
        #palette-panel {
            position: absolute;
            z-index: 51;
            background: var(--bg-ui);
            border: 1px solid var(--border-color);
            border-radius: 0.75rem;
            box-shadow: 0 8px 32px 0 rgba(0, 0, 0, 0.37);
            backdrop-filter: blur(16px);
            -webkit-backdrop-filter: blur(16px);
            padding: 0.5rem;
            display: flex;
            flex-direction: column;
            gap: 0.5rem;
            transform: translateY(-20px);
            opacity: 0;
            transition: transform 0.3s ease-out, opacity 0.3s ease-out;
            pointer-events: none;
        }
        #palette-panel.open {
            transform: translateY(0);
            opacity: 1;
            pointer-events: auto;
        }
        .palette-option {
            cursor: pointer;
            border-radius: 0.5rem;
            padding: 4px;
            border: 2px solid transparent;
            transition: border-color 0.2s;
            display: flex;
            gap: 4px;
        }
        .palette-option:hover {
            border-color: var(--switch-bg-checked);
        }
        .palette-color {
            width: 24px;
            height: 24px;
            border-radius: 0.375rem;
            border: 1px solid rgba(0,0,0,0.2);
        }

        #toolbar-color-picker-container {
            padding: 0.25rem 0;
            display: flex;
            justify-content: center;
        }
        #toolbar-accent-color-picker {
             width: 28px;
             height: 28px;
             border-radius: 50%;
        }

        /* Help Modal Styles */
        #help-modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0,0,0,0.6);
            z-index: 3000;
            display: none; /* Initially hidden */
            align-items: center;
            justify-content: center;
            backdrop-filter: blur(8px);
            -webkit-backdrop-filter: blur(8px);
        }
        #help-modal {
            background: var(--bg-ui);
            color: var(--text-color);
            padding: 2rem 3rem;
            border-radius: 1rem;
            border: 1px solid var(--border-color);
            box-shadow: 0 8px 32px 0 rgba(0, 0, 0, 0.37);
            backdrop-filter: blur(20px);
            -webkit-backdrop-filter: blur(20px);
            width: 90%;
            max-width: 800px;
            height: 80vh;
            position: relative;
            overflow: hidden;
            display: flex;
            flex-direction: column;
        }
        #close-help-btn {
            position: absolute;
            top: 1rem;
            right: 1rem;
            background: transparent;
            border: none;
            color: var(--text-color-light);
            font-size: 2rem;
            cursor: pointer;
            line-height: 1;
        }
        #help-modal h2 {
            margin: 0 0 1rem 0;
            font-size: 1.5rem;
            color: var(--text-color-strong);
            text-align: center;
        }
        .help-content {
            overflow-y: auto;
            padding-right: 1rem; /* for scrollbar */
        }
        .help-content h3 {
            color: var(--text-color-strong);
            margin-top: 1.5rem;
            margin-bottom: 0.5rem;
            border-bottom: 1px solid var(--border-color);
            padding-bottom: 0.25rem;
        }
        .help-content p, .help-content li {
            color: var(--text-color);
            font-size: 0.9rem;
            line-height: 1.6;
        }
        .help-content ul {
            list-style-type: none;
            padding-left: 0;
        }
        .help-content li {
            padding-left: 1.5rem;
            position: relative;
            margin-bottom: 0.5rem;
        }
        .help-content li::before {
            content: 'â€¢';
            color: var(--switch-bg-checked);
            position: absolute;
            left: 0;
        }
        .help-content strong {
            color: var(--text-color-strong);
            font-weight: 700;
        }
        
        /* Footer Button Styles */
        .footer-btn {
            background-color: var(--bg-ui);
            color: var(--text-color);
            width: 25px;
            height: 25px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            border: 1px solid var(--border-color);
            box-shadow: 0 8px 32px 0 rgba(0, 0, 0, 0.37);
            backdrop-filter: blur(16px);
            -webkit-backdrop-filter: blur(16px);
            transition: all 0.3s ease;
            text-decoration: none;
        }
        .footer-btn:hover {
            transform: scale(1.1);
            box-shadow: 0 12px 40px 0 rgba(0, 0, 0, 0.45);
            color: var(--switch-bg-checked);
        }

        /* Toast Notification Styles */
        #toast-container {
            position: fixed;
            bottom: calc(1.5rem + 56px + 1rem); /* Adjusted to be above the linktree button */
            right: 1.5rem;
            z-index: 5000;
            display: flex;
            flex-direction: column;
            gap: 0.75rem;
            align-items: flex-end;
        }

        .toast-notification {
            background: var(--bg-ui);
            color: var(--text-color);
            padding: 0.75rem 1.25rem;
            border-radius: 0.75rem;
            border: 1px solid var(--border-color);
            box-shadow: 0 8px 32px 0 rgba(0, 0, 0, 0.37);
            backdrop-filter: blur(16px);
            -webkit-backdrop-filter: blur(16px);
            opacity: 0;
            transform: translateX(100%);
            animation: slideIn 0.3s forwards, fadeOut 0.3s forwards 2.7s;
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .toast-notification.success .icon {
            color: #4ade80; /* green-400 */
        }
        
        .toast-notification.error .icon {
            color: #f87171; /* red-400 */
        }

        .toast-notification .icon {
            width: 20px;
            height: 20px;
        }

        @keyframes slideIn {
            to {
                opacity: 1;
                transform: translateX(0);
            }
        }

        @keyframes fadeOut {
            from {
                opacity: 1;
                transform: translateX(0);
            }
            to {
                opacity: 0;
                transform: translateX(100%);
            }
        }

        /* Responsive Styles for Mobile and Tablet */
        @media (max-width: 768px) {
            #top-bar {
                top: 0.5rem;
                padding: 0.2rem;
                gap: 0.1rem;
                flex-wrap: nowrap;
                justify-content: flex-start;
                width: auto;
                max-width: 95vw;
                overflow-x: auto;
                transform: translateX(0);
                left: 0.5rem;
            }
            #project-name-input {
                display: none;
            }
            #top-bar div[style*="margin-left: auto"] {
                display: none;
            }
            #top-bar .tool-button, #left-bar .tool-button {
                padding: 0.4rem;
                flex-shrink: 0;
            }
            #top-bar svg, #left-bar svg {
                width: 18px;
                height: 18px;
            }
            #left-bar {
                flex-direction: row;
                top: auto;
                bottom: 0.5rem;
                left: 50%;
                transform: translateX(-50%);
                width: auto;
                max-width: 95vw;
                overflow-x: auto;
                padding: 0.2rem;
            }
            .separator {
                margin: 0.1rem 0.25rem;
            }
            #context-menu {
                width: 220px;
                padding: 0.5rem;
            }
            .menu-label {
                font-size: 0.8rem;
            }
            #selection-toolbar {
                padding: 0.25rem;
                gap: 0.2rem;
                max-width: 95vw;
                overflow-x: auto;
            }
            .selection-tool-btn {
                padding: 0.3rem;
            }
            #help-modal {
                padding: 1rem 1.5rem;
                width: 95%;
                height: 85vh;
            }
            #help-modal h2 {
                font-size: 1.25rem;
            }
            .help-content p, .help-content li {
                font-size: 0.85rem;
            }
            #footer-container {
                bottom: 4rem;
                right: 0.5rem;
                gap: 0.5rem;
            }
             #version-info {
                display: none; /* Hide version text on small screens */
            }
            #toast-container {
                bottom: 7rem;
                right: 0.5rem;
            }
        }
    </style>
</head>
<body>
    <div id="top-bar">
        <div id="app-logo" title="Moodinfinite v0.7.3" style="display: flex; align-items: center; padding-left: 0.25rem; padding-right: 0.25rem; cursor: default;">
            <img src="fav_icon_alternative.png" alt="Logo" style="width: 24px; height: 24px;">
        </div>
        <div style="width: 1px; background-color: var(--border-color); margin: 0 0.25rem; align-self: stretch;"></div>
        <button id="new-file-btn" title="New Board (Shift+N)" class="tool-button">
            <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M14 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V8z"></path><polyline points="14 2 14 8 20 8"></polyline><line x1="12" y1="18" x2="12" y2="12"></line><line x1="9" y1="15" x2="15" y2="15"></line></svg>
        </button>
        <button id="load-project-btn" title="Open Project (Ctrl+O)" class="tool-button">
            <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M22 19a2 2 0 0 1-2 2H4a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h5l2 3h9a2 2 0 0 1 2 2z"></path></svg>
        </button>
        <button id="save-project-btn" title="Save Project (Ctrl+S)" class="tool-button">
            <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M19 21H5a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h11l5 5v11a2 2 0 0 1-2 2z"></path><polyline points="17 21 17 13 7 13 7 21"></polyline><polyline points="7 3 7 8 15 8"></polyline></svg>
        </button>
        <button id="save-png-btn" title="Export as PNG (Shift+S)" class="tool-button">
            <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"></path><polyline points="7 10 12 15 17 10"></polyline><line x1="12" y1="15" x2="12" y2="3"></line></svg>
        </button>
        <button id="palette-btn" title="Color Palettes" class="tool-button">
            <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-palette2" viewBox="0 0 16 16">
			  <path d="M0 .5A.5.5 0 0 1 .5 0h5a.5.5 0 0 1 .5.5v5.277l4.147-4.131a.5.5 0 0 1 .707 0l3.535 3.536a.5.5 0 0 1 0 .708L10.261 10H15.5a.5.5 0 0 1 .5.5v5a.5.5 0 0 1-.5.5H3a3 3 0 0 1-2.121-.879A3 3 0 0 1 0 13.044m6-.21 7.328-7.3-2.829-2.828L6 7.188zM4.5 13a1.5 1.5 0 1 0-3 0 1.5 1.5 0 0 0 3 0M15 15v-4H9.258l-4.015 4zM0 .5v12.495zm0 12.495V13z"/>
			</svg>
        </button>
        <button id="open-help-btn" title="Help" class="tool-button">
            <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="10"></circle><line x1="12" y1="16" x2="12" y2="12"></line><line x1="12" y1="8" x2="12.01" y2="8"></line></svg>
        </button>
        <div style="margin-left: auto; display: flex; align-items: center; padding-right: 0.5rem;">
            <input type="text" id="project-name-input" placeholder="Project Name" title="Project Name">
        </div>
    </div>

    <canvas id="moodboard-canvas"></canvas>
    
    <!-- File inputs for images and projects -->
    <input type="file" id="image-input" accept="image/png, image/jpeg, image/gif, image/svg+xml, image/webp" style="display: none;" multiple>
    <input type="file" id="project-input" accept=".json, .mood" style="display: none;">
    
    <textarea id="text-editor" style="display: none;"></textarea>

    <!-- Left Toolbar for adding elements -->
    <div id="left-bar">
        <div id="toolbar-color-picker-container">
            <input type="color" id="toolbar-accent-color-picker" class="color-picker-input" title="Accent Color">
        </div>
        <button id="eyedropper-btn" title="Eyedropper (E)" class="tool-button">
            <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-eyedropper" viewBox="0 0 16 16">
  <path d="M13.354.646a1.207 1.207 0 0 0-1.708 0L8.5 3.793l-.646-.647a.5.5 0 1 0-.708.708L8.293 5l-7.147 7.146A.5.5 0 0 0 1 12.5v1.793l-.854.853a.5.5 0 1 0 .708.707L1.707 15H3.5a.5.5 0 0 0 .354-.146L11 7.707l1.146 1.147a.5.5 0 0 0 .708-.708l-.647-.646 3.147-3.146a1.207 1.207 0 0 0 0-1.708zM2 12.707l7-7L10.293 7l-7 7H2z"></path>
</svg>
        </button>
		
		<div class="separator"></div>
		
        <button id="add-image-btn" title="Add Image (I)" class="tool-button">
            <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><rect x="3" y="3" width="18" height="18" rx="2" ry="2"></rect><circle cx="8.5" cy="8.5" r="1.5"></circle><polyline points="21 15 15 9 5 19"></polyline></svg>
        </button>
        
        <div class="separator"></div>

        <button id="select-tool-btn" title="Select (A)" class="tool-button active">
            <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M3 3l7.07 16.97 2.51-7.39 7.39-2.51L3 3z"></path><path d="M13 13l6 6"></path></svg>
        </button>
        <button id="add-text-btn" title="Add Text (T)" class="tool-button">
            <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polyline points="4 7 4 4 20 4 20 7"></polyline><line x1="9" y1="20" x2="15" y2="20"></line><line x1="12" y1="4" x2="12" y2="20"></line></svg>
        </button>
        <button id="draw-btn" title="Draw (D)" class="tool-button">
            <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M12 19l7-7 3 3-7 7-3-3z"></path><path d="M18 13l-1.5-7.5L2 2l3.5 14.5L13 18l5-5z"></path><path d="M2 2l7.586 7.586"></path></svg>
        </button>
        <button id="add-arrow-btn" title="Add Arrow (Shift+A)" class="tool-button">
           <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><line x1="5" y1="12" x2="19" y2="12"></line><polyline points="12 5 19 12 12 19"></polyline></svg>
        </button>
        <button id="add-box-btn" title="Add Box (B)" class="tool-button">
            <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><rect x="3" y="3" width="18" height="18" rx="2" ry="2"></rect></svg>
        </button>
        <button id="add-grid-btn" title="Add Grid (Alt+G)" class="tool-button">
            <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><rect x="3" y="3" width="18" height="18" rx="2" ry="2"></rect><line x1="3" y1="9" x2="21" y2="9"></line><line x1="3" y1="15" x2="21" y2="15"></line><line x1="9" y1="3" x2="9" y2="21"></line><line x1="15" y1="3" x2="15" y2="21"></line></svg>
        </button>

        <div class="separator"></div>
        
        <button id="align-btn" title="Auto Align Selection" class="tool-button" disabled>
            <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><rect x="3" y="3" width="7" height="7"></rect><rect x="14" y="3" width="7" height="7"></rect><rect x="14" y="14" width="7" height="7"></rect><rect x="3" y="14" width="7" height="7"></rect></svg>
        </button>
    </div>

    <!-- Right-click context menu -->
    <div id="context-menu">
        <div class="menu-item">
            <label class="menu-label">Colors</label>
            <div class="flex items-center gap-2">
                <input type="color" id="bg-color-picker" class="color-picker-input" value="#0d0d0d" title="Background Color">
                <input type="color" id="accent-color-picker" class="color-picker-input" value="#429eff" title="Accent Color">
                <input type="color" id="grid-color-picker" class="color-picker-input" value="#f9f8f6" title="Grid Color">
            </div>
        </div>
        <div class="menu-item">
            <label for="drop-shadow-toggle" class="menu-label">Drop Shadow</label>
            <label class="switch">
                <input type="checkbox" id="drop-shadow-toggle" checked>
                <span class="slider"></span>
            </label>
        </div>
        <div class="menu-item">
            <label for="show-notifications-toggle" class="menu-label">Show Notifications</label>
            <label class="switch">
                <input type="checkbox" id="show-notifications-toggle" checked>
                <span class="slider"></span>
            </label>
        </div>
        <div class="border-t my-2" id="opacity-separator" style="border-color: var(--border-color); display: none;"></div>
        <div class="menu-item" id="opacity-slider-container" style="display: none;">
            <label for="item-opacity-slider" class="menu-label">Opacity</label>
            <div class="flex items-center gap-2" style="width: 60%;">
                <input type="range" id="item-opacity-slider" min="0.05" max="1" step="0.05" value="1" class="slider-input">
                <div id="item-opacity-value" class="slider-value-box">100%</div>
            </div>
        </div>
        <div class="border-t my-2" style="border-color: var(--border-color);"></div>
        <div class="menu-item">
            <label for="show-grid-toggle" class="menu-label">Show Grid</label>
            <label class="switch">
                <input type="checkbox" id="show-grid-toggle" checked>
                <span class="slider"></span>
            </label>
        </div>
        <div class="menu-item">
            <label for="snap-grid-toggle" class="menu-label">Snap to Grid</label>
            <label class="switch">
                <input type="checkbox" id="snap-grid-toggle" checked>
                <span class="slider"></span>
            </label>
        </div>
        <div class="menu-item">
            <label for="grid-opacity-slider" class="menu-label">Grid Opacity</label>
            <div class="flex items-center gap-2" style="width: 60%;">
                <input type="range" id="grid-opacity-slider" min="0" max="1" step="0.05" value="0.05" class="slider-input">
                <div id="grid-opacity-value" class="slider-value-box">5%</div>
            </div>
        </div>
        <div class="menu-item">
            <label for="grid-size-slider" class="menu-label">Grid Size</label>
            <div class="flex items-center gap-2" style="width: 60%;">
                <input type="range" id="grid-size-slider" min="10" max="200" value="50" class="slider-input">
                <div id="grid-size-value" class="slider-value-box">50px</div>
            </div>
        </div>
         <div class="border-t my-2" id="download-separator" style="border-color: var(--border-color); display: none;"></div>
         <div class="menu-item" id="download-image-btn" style="display: none;">
             <span class="menu-label">Download Source</span>
             <svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"></path><polyline points="7 10 12 15 17 10"></polyline><line x1="12" y1="15" x2="12" y2="3"></line></svg>
         </div>
         <div class="border-t my-2" id="delete-separator" style="border-color: var(--border-color);"></div>
         <div class="menu-item" id="delete-item-btn">
             <span class="menu-label text-red-500">Delete Selected</span>
             <svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="text-red-500"><polyline points="3 6 5 6 21 6"></polyline><path d="M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6m3 0V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2"></path></svg>
         </div>
    </div>
    
    <div id="palette-panel"></div>

    <div id="box-color-picker-container">
        <input type="color" id="box-color-picker" class="color-picker-input">
    </div>

    <!-- Floating toolbar for selected items -->
    <div id="selection-toolbar">
        <div id="text-tools-container">
            <select id="font-family-select" class="selection-tool-select" title="Font Family">
                <option value="Inter">Inter</option>
                <option value="Roboto">Roboto</option>
                <option value="Playfair Display">Playfair</option>
                <option value="Source Code Pro">Code</option>
            </select>
            <button id="text-align-left-btn" class="selection-tool-btn" title="Align Left">
                <svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><line x1="17" y1="10" x2="3" y2="10"></line><line x1="21" y1="6" x2="3" y2="6"></line><line x1="17" y1="14" x2="3" y2="14"></line><line x1="21" y1="18" x2="3" y2="18"></line></svg>
            </button>
            <button id="text-align-center-btn" class="selection-tool-btn" title="Align Center">
                <svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><line x1="18" y1="10" x2="6" y2="10"></line><line x1="21" y1="6" x2="3" y2="6"></line><line x1="18" y1="14" x2="6" y2="14"></line><line x1="21" y1="18" x2="3" y2="18"></line></svg>
            </button>
            <button id="text-align-right-btn" class="selection-tool-btn" title="Align Right">
                <svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><line x1="21" y1="10" x2="7" y2="10"></line><line x1="21" y1="6" x2="3" y2="6"></line><line x1="21" y1="14" x2="7" y2="14"></line><line x1="21" y1="18" x2="3" y2="18"></line></svg>
            </button>
            <button id="text-style-bold-btn" class="selection-tool-btn" title="Bold">
                <svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M6 4h8a4 4 0 0 1 4 4 4 4 0 0 1-4 4H6z"></path><path d="M6 12h9a4 4 0 0 1 4 4 4 4 0 0 1-4 4H6z"></path></svg>
            </button>
            <button id="text-style-italic-btn" class="selection-tool-btn" title="Italic">
                <svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><line x1="19" y1="4" x2="10" y2="4"></line><line x1="14" y1="20" x2="5" y2="20"></line><line x1="15" y1="4" x2="9" y2="20"></line></svg>
            </button>
        </div>
        <div id="grid-tools-container">
            <label for="grid-rows-input" class="selection-tool-btn" title="Rows">
                <svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><line x1="3" y1="12" x2="21" y2="12"></line><line x1="3" y1="6" x2="21" y2="6"></line><line x1="3" y1="18" x2="21" y2="18"></line></svg>
            </label>
            <input type="number" id="grid-rows-input" class="grid-input" min="1">
            <label for="grid-cols-input" class="selection-tool-btn" title="Columns">
                 <svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><line x1="12" y1="3" x2="12" y2="21"></line><line x1="6" y1="3" x2="6" y2="21"></line><line x1="18" y1="3" x2="18" y2="21"></line></svg>
            </label>
            <input type="number" id="grid-cols-input" class="grid-input" min="1">
        </div>
         <button id="toggle-box-style-btn" class="selection-tool-btn" title="Toggle Box Style">
            <svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><rect x="3" y="3" width="18" height="18" rx="2" ry="2"></rect></svg>
        </button>
        <button id="group-btn" class="selection-tool-btn" title="Group (Ctrl+G)">
            <svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><rect x="8" y="8" width="12" height="12" rx="2" ry="2"></rect><path d="M4 16c-1.1 0-2-.9-2-2V4c0-1.1.9-2 2-2h10c1.1 0 2 .9 2 2"></path></svg>
        </button>
        <button id="ungroup-btn" class="selection-tool-btn" title="Ungroup (Ctrl+Shift+G)">
            <svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><rect x="8" y="8" width="12" height="12" rx="2" ry="2" stroke-dasharray="2 2"></rect><path d="M4 16c-1.1 0-2-.9-2-2V4c0-1.1.9-2 2-2h10c1.1 0 2 .9 2 2v2"></path></svg>
        </button>
        <button id="bring-front-btn" class="selection-tool-btn" title="Bring to Front (Home)">
            <svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M3 3v18h18"/><path d="M21 21V8a2 2 0 0 0-2-2H8a2 2 0 0 0-2 2v13"/></svg>
        </button>
        <button id="send-back-btn" class="selection-tool-btn" title="Send to Back (End)">
            <svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 16V4a2 2 0 0 0-2-2H4a2 2 0 0 0-2 2v12a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2v-1"/><path d="M8 22v-4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v4"/></svg>
        </button>
        <button id="scale-btn" class="selection-tool-btn" title="Scale (S)">
            <svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 21l-6-6m6 6v-4m0 4h-4"></path><path d="M3 3l6 6m-6-6v4m0-4h4"></path></svg>
        </button>
        <button id="rotate-btn" class="selection-tool-btn" title="Rotate (R)">
            <svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M23 4v6h-6"></path><path d="M1 20v-6h6"></path><path d="M3.51 9a9 9 0 0 1 14.85-3.36L23 10M1 14l4.64 4.36A9 9 0 0 0 20.49 15"></path></svg>
        </button>
        <button id="pin-btn" class="selection-tool-btn" title="Pin (P)">
            <svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15.05 5A5 5 0 0 1 19 8.95M15.05 1A9 9 0 0 1 23 8.94m-1 7.05A5 5 0 0 1 18 19.05M16 13l-6 6-4-4-6-6"></path></svg>
        </button>
        <button id="delete-selection-btn" class="selection-tool-btn" title="Delete (Del)">
            <svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="text-red-500"><polyline points="3 6 5 6 21 6"></polyline><path d="M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6m3 0V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2"></path></svg>
        </button>
    </div>

    <!-- Confirmation Modal for New Board -->
    <div id="confirmation-modal-overlay">
        <div id="confirmation-modal">
            <h2>Create New Board?</h2>
            <p>All unsaved changes will be lost. Are you sure you want to continue?</p>
            <div class="modal-buttons">
                <button id="cancel-new-btn" class="modal-button cancel">Cancel</button>
                <button id="confirm-new-btn" class="modal-button confirm">Yes, Clear Board</button>
            </div>
        </div>
    </div>
    
    <!-- Help Modal -->
    <div id="help-modal-overlay">
        <div id="help-modal">
            <button id="close-help-btn">&times;</button>
            <img src="https://github.com/davidbrum25/moodinfinite/blob/main/_branding/_png/moodinfinite__Logotipo_alpha.png" alt="Moodinfinite Logo" style="width: 27vh;height: 9vh;margin: 0 auto 1rem;">
            <h2>Moodinfinite Help</h2>
            <div class="help-content">
                <h3>Welcome!</h3>
                <p>Moodinfinite is a digital canvas for your ideas. Add images, text, arrows, and more to create moodboards, brainstorm, or organize your thoughts.</p>
                
                <h3>Core Concepts</h3>
                <ul>
                    <li><strong>Panning & Zooming:</strong> On Desktop, use the mouse wheel to zoom and middle-click (or Space + left-click) to pan. On Touch devices, <strong>pinch with two fingers</strong> to zoom and <strong>drag with two fingers</strong> to pan.</li>
                    <li><strong>Context Menu:</strong> Right-click on Desktop. <strong>Long press</strong> on a Touch device.</li>
                    <li><strong>Selecting:</strong> Tap or Click on an item to select it. Hold <strong>Shift</strong> and click to select multiple items. Click and drag on an empty area to create a selection box.</li>
                     <li><strong>Deselect:</strong> Press <strong>Escape</strong> to clear your current selection.</li>
                </ul>

                <h3>Tools & Hotkeys</h3>
                 <ul>
                    <li><strong>Select (V):</strong> The default tool for selecting, moving, and interacting with items.</li>
                    <li><strong>Add Image (I):</strong> Opens a file dialog to add images. You can also paste images directly or drag-and-drop them onto the canvas.</li>
                    <li><strong>Add Text (T):</strong> Tap and drag to create a text box. Double-tap an existing text box to edit it.</li>
                    <li><strong>Add Arrow (A):</strong> Tap and drag to draw an arrow.</li>
                    <li><strong>Add Box (B):</strong> Tap and drag to create a colored rectangle.</li>
                    <li><strong>Add Grid (Alt+G):</strong> Tap and drag to create a grid. Adjust rows and columns from the selection toolbar.</li>
                    <li><strong>Draw (D):</strong> Freehand drawing tool.</li>
                    <li><strong>Eyedropper (E):</strong> Pick a color from the canvas to set as your current accent color.</li>
                </ul>

                <h3>Item Manipulation</h3>
                <p>When you select an item, a floating toolbar appears with context-specific actions.</p>
                <ul>
                    <li><strong>Layering:</strong> Bring an item to the very front with <strong>Home</strong> or send it to the very back with <strong>End</strong>. Move one layer at a time with <strong>Page Up</strong> and <strong>Page Down</strong>.</li>
                    <li><strong>Grouping:</strong> Select multiple items and press <strong>Ctrl+G</strong> to group them. A group can be moved, rotated, and scaled as a single object.</li>
                    <li><strong>Ungrouping:</strong> Select a group and press <strong>Ctrl+Shift+G</strong> to break it back into its individual items.</li>
                    <li><strong>Scale (S):</strong> With a single item selected, press <strong>S</strong> to activate scale mode. Drag the handle that appears on the bottom-right corner. Hold <strong>Shift</strong> while scaling to maintain the original aspect ratio.</li>
                    <li><strong>Rotate (R):</strong> With a single item selected, press <strong>R</strong> to activate rotate mode. Drag the handle that appears on the top. Hold <strong>Shift</strong> to snap rotation to 15-degree increments.</li>
                    <li><strong>Pin (P):</strong> Lock an item in place to prevent accidental movement or editing.</li>
                    <li><strong>Delete (Del / Backspace):</strong> Remove the selected item(s).</li>
                     <li><strong>Auto Align (Shift+A):</strong> Neatly arranges two or more selected items into a grid.</li>
                </ul>

                <h3>General Hotkeys</h3>
                <ul>
                    <li><strong>New Board:</strong> Shift+N</li>
                    <li><strong>Open Project:</strong> Ctrl+O</li>
                    <li><strong>Save Project:</strong> Ctrl+S</li>
                    <li><strong>Export as PNG:</strong> Shift+S</li>
                    <li><strong>Copy:</strong> Ctrl+C</li>
                    <li><strong>Cut:</strong> Ctrl+X</li>
                    <li><strong>Paste:</strong> Ctrl+V</li>
                    <li><strong>Duplicate:</strong> Ctrl+D</li>
                    <li><strong>Undo:</strong> Ctrl+Z</li>
                    <li><strong>Redo:</strong> Ctrl+Shift+Z</li>
                    <li><strong>Select All:</strong> Ctrl+A</li>
                    <li><strong>Toggle Background Grid:</strong> G</li>
                    <li><strong>Open Help:</strong> H</li>
                </ul>

                <h3>Credits</h3>
                <p style="line-height: 1.8;">
                    Made by H. David Brum<br>
                    <a href="mailto:davidbrum.5@gmail.com" target="_blank" style="color: var(--switch-bg-checked); text-decoration: none;">davidbrum.5@gmail.com</a><br>
                    <a href="https://linktr.ee/davidbrum" target="_blank" style="color: var(--switch-bg-checked); text-decoration: none;">linktr.ee/davidbrum</a>
                </p>
            </div>
        </div>
    </div>

    <!-- Footer container -->
    <div id="footer-container" style="position: fixed; bottom: 1.5rem; right: 1.5rem; z-index: 4999; display: flex; align-items: center; gap: 0.75rem;">
        <div id="version-info" style="font-size: 0.75rem; color: var(--text-color-light); opacity: 0.5; pointer-events: none;">
            MOODinfinite Current stable version: v0.7.3
        </div>
        <!-- Patreon Button -->
        <a href="https://www.patreon.com/cw/bdvd" target="_blank" class="footer-btn" title="Support on Patreon">
            <svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg" style="width: 55%;">
                <path d="M15.48 2.49C10.97 2.49 7.32 6.14 7.32 10.65C7.32 15.16 10.97 18.81 15.48 18.81C19.99 18.81 23.64 15.16 23.64 10.65C23.64 6.14 19.99 2.49 15.48 2.49ZM0.36 2.49V18.81H4.2V2.49H0.36Z"/>
            </svg>
        </a>
        <!-- Linktree Button -->
        <a href="https://linktr.ee/davidbrum" target="_blank" class="footer-btn" title="H. David Brum Links">
            <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-link" style="width: 60%;"><path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.72"></path><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.72-1.72"></path></svg>
        </a>
    </div>


    <!-- Toast Notification Container -->
    <div id="toast-container"></div>

    <script>
        // Canvas and DOM Elements
        const canvas = document.getElementById('moodboard-canvas');
        const ctx = canvas.getContext('2d');
        const imageInput = document.getElementById('image-input');
        const projectInput = document.getElementById('project-input');
        const newFileBtn = document.getElementById('new-file-btn');
        const addImageBtn = document.getElementById('add-image-btn');
        const addTextBtn = document.getElementById('add-text-btn');
        const addArrowBtn = document.getElementById('add-arrow-btn');
        const addBoxBtn = document.getElementById('add-box-btn');
        const addGridBtn = document.getElementById('add-grid-btn');
        const drawBtn = document.getElementById('draw-btn');
        const alignBtn = document.getElementById('align-btn');
        const contextMenu = document.getElementById('context-menu');
        const showGridToggle = document.getElementById('show-grid-toggle');
        const snapGridToggle = document.getElementById('snap-grid-toggle');
        const dropShadowToggle = document.getElementById('drop-shadow-toggle');
        const showNotificationsToggle = document.getElementById('show-notifications-toggle');
        const gridSizeSlider = document.getElementById('grid-size-slider');
        const gridSizeValue = document.getElementById('grid-size-value');
        const gridOpacitySlider = document.getElementById('grid-opacity-slider');
        const gridOpacityValue = document.getElementById('grid-opacity-value');
        const deleteItemBtn = document.getElementById('delete-item-btn');
        const savePngBtn = document.getElementById('save-png-btn');
        const saveProjectBtn = document.getElementById('save-project-btn');
        const loadProjectBtn = document.getElementById('load-project-btn');
        const bgColorPicker = document.getElementById('bg-color-picker');
        const accentColorPicker = document.getElementById('accent-color-picker');
        const gridColorPicker = document.getElementById('grid-color-picker');
        const toolbarAccentColorPicker = document.getElementById('toolbar-accent-color-picker');
        const textEditor = document.getElementById('text-editor');
        const boxColorPickerContainer = document.getElementById('box-color-picker-container');
        const boxColorPicker = document.getElementById('box-color-picker');
        const selectionToolbar = document.getElementById('selection-toolbar');
        const toggleBoxStyleBtn = document.getElementById('toggle-box-style-btn');
        const scaleBtn = document.getElementById('scale-btn');
        const rotateBtn = document.getElementById('rotate-btn');
        const pinBtn = document.getElementById('pin-btn');
        const deleteSelectionBtn = document.getElementById('delete-selection-btn');
        const bringFrontBtn = document.getElementById('bring-front-btn');
        const sendBackBtn = document.getElementById('send-back-btn');
        const confirmationModalOverlay = document.getElementById('confirmation-modal-overlay');
        const confirmNewBtn = document.getElementById('confirm-new-btn');
        const cancelNewBtn = document.getElementById('cancel-new-btn');
        const opacitySliderContainer = document.getElementById('opacity-slider-container');
        const opacitySeparator = document.getElementById('opacity-separator');
        const itemOpacitySlider = document.getElementById('item-opacity-slider');
        const itemOpacityValue = document.getElementById('item-opacity-value');
        const paletteBtn = document.getElementById('palette-btn');
        const palettePanel = document.getElementById('palette-panel');
        const eyedropperBtn = document.getElementById('eyedropper-btn');
        const groupBtn = document.getElementById('group-btn');
        const ungroupBtn = document.getElementById('ungroup-btn');
        const textToolsContainer = document.getElementById('text-tools-container');
        const gridToolsContainer = document.getElementById('grid-tools-container');
        const gridRowsInput = document.getElementById('grid-rows-input');
        const gridColsInput = document.getElementById('grid-cols-input');
        const fontFamilySelect = document.getElementById('font-family-select');
        const textAlignLeftBtn = document.getElementById('text-align-left-btn');
        const textAlignCenterBtn = document.getElementById('text-align-center-btn');
        const textAlignRightBtn = document.getElementById('text-align-right-btn');
        const textStyleBoldBtn = document.getElementById('text-style-bold-btn');
        const textStyleItalicBtn = document.getElementById('text-style-italic-btn');
        const openHelpBtn = document.getElementById('open-help-btn');
        const helpModalOverlay = document.getElementById('help-modal-overlay');
        const closeHelpBtn = document.getElementById('close-help-btn');
        const selectToolBtn = document.getElementById('select-tool-btn');
        const projectNameInput = document.getElementById('project-name-input');
        const downloadImageBtn = document.getElementById('download-image-btn');
        const downloadSeparator = document.getElementById('download-separator');


        // State Variables
        let cameraOffset = { x: 0, y: 0 };
        let cameraZoom = 1;
        const MAX_ZOOM = 5, MIN_ZOOM = 0.1, SCROLL_SENSITIVITY = 0.0005;
        let isDragging = false, dragStart = { x: 0, y: 0 };
        let items = [], selectedItems = []; 
        let clipboard = [];
        let isMovingItems = false, moveStart = {x: 0, y: 0};
        let currentTool = null, isDrawing = false;
        let canvasBackgroundColor = '#0d0d0d', accentColor = '#429eff', gridColor = '#f9f8f6';
        let activeGizmo = null, isTransforming = false, isTransformingArrow = false;
        let transformingHandle = null, transformStart = { x: 0, y: 0 }, originalItemState = null;
        let hoveredGizmo = null, hoveredArrowHandle = null;
        let isSelectingBox = false, selectionBox = { startX: 0, startY: 0, endX: 0, endY: 0 };
        let currentlyEditingText = null;
        let showGrid = true, snapToGrid = true, showDropShadow = true, showNotifications = true;
        let gridSize = 50, gridOpacity = 0.05;
        let currentProjectName = 'moodinfinite';

        // History/Undo State
        let historyStack = [];
        let historyIndex = -1;
        const HISTORY_LIMIT = 50;

        const colorPalettes = [
            { bg: '#0d0d0d', accent: '#429eff', grid: '#ffffff' },
            { bg: '#173640', accent: '#429eff', grid: '#ffffff' },
            { bg: '#bfbfbf', accent: '#fe345c', grid: '#000000' }
        ];

        // --- CORE FUNCTIONS ---

        function setupEventListeners() {
            // Mouse Listeners
            canvas.addEventListener('mousedown', onMouseDown);
            canvas.addEventListener('mouseup', onMouseUp);
            canvas.addEventListener('mousemove', onMouseMove);
            canvas.addEventListener('dblclick', onDoubleClick);
            canvas.addEventListener('wheel', (e) => { e.preventDefault(); adjustZoom(e, -e.deltaY * SCROLL_SENSITIVITY); });
            canvas.addEventListener('contextmenu', onContextMenu);
            
            // Touch Listeners for mobile/tablet support
            canvas.addEventListener('touchstart', onTouchStart, { passive: false });
            canvas.addEventListener('touchend', onTouchEnd, { passive: false });
            canvas.addEventListener('touchmove', onTouchMove, { passive: false });
            canvas.addEventListener('touchcancel', onTouchEnd, { passive: false });

            // Window and Document Listeners
            window.addEventListener('resize', resizeCanvas);
            window.addEventListener('keydown', handleKeyDown);
            document.addEventListener('click', (e) => { 
                if (!contextMenu.contains(e.target)) contextMenu.style.display = 'none';
                if (palettePanel.classList.contains('open') && !palettePanel.contains(e.target) && e.target !== paletteBtn && !paletteBtn.contains(e.target)) {
                    palettePanel.classList.remove('open');
                }
            });
            
            // Drag and drop listeners for images and projects
            window.addEventListener('paste', handlePaste);
            canvas.addEventListener('dragover', handleDragOver);
            canvas.addEventListener('dragleave', handleDragLeave);
            canvas.addEventListener('drop', handleDrop);

            // Button listeners
            openHelpBtn.addEventListener('click', () => helpModalOverlay.style.display = 'flex');
            closeHelpBtn.addEventListener('click', () => helpModalOverlay.style.display = 'none');
            helpModalOverlay.addEventListener('click', (e) => {
                if (e.target === helpModalOverlay) {
                    helpModalOverlay.style.display = 'none';
                }
            });
            newFileBtn.addEventListener('click', confirmNewBoard);
            savePngBtn.addEventListener('click', saveAsPng);
            saveProjectBtn.addEventListener('click', saveProject);
            loadProjectBtn.addEventListener('click', () => projectInput.click());
            paletteBtn.addEventListener('click', () => {
                if (palettePanel.classList.contains('open')) {
                    palettePanel.classList.remove('open');
                } else {
                    const btnRect = paletteBtn.getBoundingClientRect();
                    palettePanel.style.left = `${btnRect.left}px`;
                    palettePanel.style.top = `${btnRect.bottom + 8}px`; // 8px margin
                    palettePanel.classList.add('open');
                }
            });
            addImageBtn.addEventListener('click', () => imageInput.click());
            imageInput.addEventListener('change', handleImageUpload);
            projectInput.addEventListener('change', handleProjectUpload);
            addArrowBtn.addEventListener('click', () => setCurrentTool('arrow'));
            addTextBtn.addEventListener('click', () => setCurrentTool('text'));
            addBoxBtn.addEventListener('click', () => setCurrentTool('box'));
            addGridBtn.addEventListener('click', () => setCurrentTool('grid'));
            drawBtn.addEventListener('click', () => setCurrentTool('draw'));
            eyedropperBtn.addEventListener('click', () => setCurrentTool('eyedropper'));
            alignBtn.addEventListener('click', autoAlignSelection);
            selectToolBtn.addEventListener('click', () => setCurrentTool(null));
            
            // Context Menu listeners
            showGridToggle.addEventListener('change', (e) => showGrid = e.target.checked);
            snapGridToggle.addEventListener('change', (e) => snapToGrid = e.target.checked);
            dropShadowToggle.addEventListener('change', (e) => showDropShadow = e.target.checked);
            showNotificationsToggle.addEventListener('change', (e) => showNotifications = e.target.checked);
            gridSizeSlider.addEventListener('input', (e) => { gridSize = parseInt(e.target.value); gridSizeValue.textContent = `${gridSize}px`; });
            gridOpacitySlider.addEventListener('input', (e) => { gridOpacity = parseFloat(e.target.value); gridOpacityValue.textContent = `${Math.round(gridOpacity * 100)}%`; });
            deleteItemBtn.addEventListener('click', deleteSelectedItems);
            bgColorPicker.addEventListener('input', e => { canvasBackgroundColor = e.target.value; updateUIColors(); });
            accentColorPicker.addEventListener('input', e => { 
                accentColor = e.target.value; 
                updateUIColors(); 
            });
             toolbarAccentColorPicker.addEventListener('input', e => { 
                accentColor = e.target.value; 
                updateUIColors(); 
            });
            gridColorPicker.addEventListener('input', e => { gridColor = e.target.value; });
            itemOpacitySlider.addEventListener('input', (e) => {
                const newOpacity = parseFloat(e.target.value);
                selectedItems.forEach(item => {
                    item.opacity = newOpacity;
                });
                itemOpacityValue.textContent = `${Math.round(newOpacity * 100)}%`;
            });
            itemOpacitySlider.addEventListener('change', () => {
                saveStateForUndo();
            });

            // Selection Toolbar listeners
            toggleBoxStyleBtn.addEventListener('click', toggleBoxStyle);
            groupBtn.addEventListener('click', groupSelectedItems);
            ungroupBtn.addEventListener('click', ungroupSelectedItems);
            scaleBtn.addEventListener('click', () => setActiveGizmo('scale'));
            rotateBtn.addEventListener('click', () => setActiveGizmo('rotate'));
            pinBtn.addEventListener('click', togglePin);
            deleteSelectionBtn.addEventListener('click', deleteSelectedItems);
            bringFrontBtn.addEventListener('click', bringSelectedToFront);
            sendBackBtn.addEventListener('click', sendSelectedToBack);
            fontFamilySelect.addEventListener('change', setTextFontFamily);
            textAlignLeftBtn.addEventListener('click', () => setTextAlign('left'));
            textAlignCenterBtn.addEventListener('click', () => setTextAlign('center'));
            textAlignRightBtn.addEventListener('click', () => setTextAlign('right'));
            textStyleBoldBtn.addEventListener('click', toggleTextStyleBold);
            textStyleItalicBtn.addEventListener('click', toggleTextStyleItalic);
            gridRowsInput.addEventListener('change', (e) => updateGridDimension('rows', e.target.value));
            gridColsInput.addEventListener('change', (e) => updateGridDimension('cols', e.target.value));


            // Text and color picker listeners
            textEditor.addEventListener('blur', finishEditingText);
            textEditor.addEventListener('input', autoResizeTextEditor);
            textEditor.addEventListener('keydown', (e) => { if (e.key === 'Escape') finishEditingText(); });
            boxColorPicker.addEventListener('input', (e) => {
                if(selectedItems.length === 1 && selectedItems[0].type === 'box'){
                    selectedItems[0].color = e.target.value;
                }
            });

            // Confirmation Modal Listeners
            confirmNewBtn.addEventListener('click', () => { 
                resetBoard();
                hideConfirmationModal(); 
            });
            cancelNewBtn.addEventListener('click', hideConfirmationModal);
            
            projectNameInput.addEventListener('change', () => {
                const newName = projectNameInput.value.trim();
                if (newName) {
                    currentProjectName = newName.replace(/\.json$|\.mood$/i, '');
                    projectNameInput.value = currentProjectName;
                } else {
                    currentProjectName = 'moodboard';
                    projectNameInput.value = currentProjectName;
                }
            });

            downloadImageBtn.addEventListener('click', downloadSourceImage);
        }
        
        function resizeCanvas() { 
            cameraOffset.x += (window.innerWidth - canvas.width) / 2;
            cameraOffset.y += (window.innerHeight - canvas.height) / 2;
            canvas.width = window.innerWidth; 
            canvas.height = window.innerHeight; 
        }

        // Main animation loop
        function gameLoop(){
            draw();
            updateToolbarPosition();
            requestAnimationFrame(gameLoop);
        }

        // --- DRAWING FUNCTIONS ---

        function draw() {
            // Reset canvas and apply camera transforms
            ctx.setTransform(1, 0, 0, 1, 0, 0);
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            ctx.save();
            ctx.translate(canvas.width / 2, canvas.height / 2);
            ctx.scale(cameraZoom, cameraZoom);
            ctx.translate(-canvas.width / 2 + cameraOffset.x, -canvas.height / 2 + cameraOffset.y);
            
            if (showGrid) drawGrid();
            
            // 1. Draw all items
            items.forEach(item => {
                if(item.isHidden) return;
                ctx.save();
                ctx.globalAlpha = item.opacity ?? 1;
                if (showDropShadow) {
                    ctx.shadowColor = 'rgba(0, 0, 0, 0.4)';
                    ctx.shadowBlur = 15 / cameraZoom;
                    ctx.shadowOffsetX = 4 / cameraZoom;
                    ctx.shadowOffsetY = 4 / cameraZoom;
                }
                if(item.type === 'image') {
                    const centerX = item.x + item.width / 2, centerY = item.y + item.height / 2;
                    ctx.translate(centerX, centerY);
                    ctx.rotate(item.rotation);
                    ctx.translate(-centerX, -centerY);
                    if (item.img.complete) {
                        ctx.drawImage(item.img, item.x, item.y, item.width, item.height);
                    }
                } else if (item.type === 'arrow') {
                    drawArrow(ctx, item);
                } else if (item.type === 'text') {
                    drawTextItem(ctx, item);
                } else if (item.type === 'box') {
                    drawBoxItem(ctx, item);
                } else if (item.type === 'stroke') {
                    drawStrokeItem(ctx, item);
                } else if (item.type === 'grid') {
                    drawGridItem(ctx, item);
                } else if (item.type === 'group') {
                    drawGroupItem(ctx, item);
                }
                ctx.restore();
            });
            
            // 2. Draw selections on top of all items
            selectedItems.forEach(item => {
                drawSelection(item);
            });

            if(isSelectingBox) drawSelectionBox();
            ctx.restore();
        }

        function drawSelection(item) {
            // For multiple selections, just draw a simple outline
            if (selectedItems.length > 1) { 
                drawSelectionOutline(item); 
                return; 
            }
            
            // For a single selected arrow or stroke, draw its handles/box
            if (item.type === 'arrow' && !item.isPinned) {
                 const handleSize = 8 / cameraZoom, gizmoColor = invertColor(canvasBackgroundColor);
                ctx.save();
                ctx.fillStyle = gizmoColor;
                ctx.shadowColor = 'rgba(0, 0, 0, 0.4)';
                ctx.shadowBlur = 4 / cameraZoom;
                ctx.beginPath();
                ctx.arc(item.startX, item.startY, handleSize, 0, Math.PI * 2);
                ctx.fill();
                if (hoveredArrowHandle === 'start') { ctx.strokeStyle = accentColor; ctx.lineWidth = 2 / cameraZoom; ctx.stroke(); }
                ctx.beginPath();
                ctx.arc(item.endX, item.endY, handleSize, 0, Math.PI * 2);
                ctx.fill();
                if (hoveredArrowHandle === 'end') { ctx.strokeStyle = accentColor; ctx.lineWidth = 2 / cameraZoom; ctx.stroke(); }
                ctx.restore();
                return; 
            }
             if (item.type === 'stroke') {
                drawSelectionOutline(item);
                return;
            }

            // For other single selected items, draw outline and gizmos
            ctx.save();
            const centerX = item.x + item.width / 2, centerY = item.y + item.height / 2;
            ctx.translate(centerX, centerY);
            ctx.rotate(item.rotation);
            ctx.strokeStyle = accentColor;
            ctx.lineWidth = 2 / cameraZoom;
            ctx.strokeRect(-item.width / 2, -item.height / 2, item.width, item.height);
            if (activeGizmo && !item.isPinned) {
                const gizmoColor = invertColor(canvasBackgroundColor), handleSize = 8 / cameraZoom;
                ctx.shadowColor = 'rgba(0, 0, 0, 0.4)';
                ctx.shadowBlur = 4 / cameraZoom;
                ctx.fillStyle = gizmoColor;
                ctx.strokeStyle = gizmoColor;
                if (activeGizmo === 'scale') {
                    const cornerX = item.width / 2, cornerY = item.height / 2;
                    ctx.beginPath();
                    ctx.arc(cornerX, cornerY, handleSize, 0, Math.PI * 2);
                    ctx.fill();
                    if (hoveredGizmo === 'scale') { ctx.strokeStyle = accentColor; ctx.lineWidth = 2 / cameraZoom; ctx.stroke(); }
                } else if (activeGizmo === 'rotate') {
                    const cornerX = item.width / 2, cornerY = -item.height / 2;
                    const handleY = cornerY - 20 / cameraZoom;
                    ctx.beginPath();
                    ctx.moveTo(cornerX, cornerY);
                    ctx.lineTo(cornerX, handleY);
                    ctx.stroke();
                    ctx.beginPath();
                    ctx.arc(cornerX, handleY, handleSize, 0, Math.PI * 2);
                    ctx.fill();
                    if (hoveredGizmo === 'rotate') { ctx.strokeStyle = accentColor; ctx.lineWidth = 2 / cameraZoom; ctx.stroke(); }
                }
            }
            ctx.restore();
        }

        function drawSelectionOutline(item) {
            ctx.save();
            const box = getItemBoundingBox(item);
            ctx.strokeStyle = accentColor;
            ctx.lineWidth = 2 / cameraZoom;
            ctx.setLineDash([6 / cameraZoom, 4 / cameraZoom]);
            ctx.strokeRect(box.x, box.y, box.width, box.height);
            ctx.restore();
        }

        function drawSelectionBox() {
            ctx.save();
            ctx.fillStyle = hexToRgba(accentColor, 0.1);
            ctx.strokeStyle = accentColor;
            ctx.lineWidth = 1 / cameraZoom;
            const { x, y, width, height } = getNormalizedSelectionBox();
            ctx.fillRect(x, y, width, height);
            ctx.strokeRect(x, y, width, height);
            ctx.restore();
        }

        function drawGrid() {
            const worldLeft = (0 - canvas.width / 2) / cameraZoom - cameraOffset.x + canvas.width / 2;
            const worldTop = (0 - canvas.height / 2) / cameraZoom - cameraOffset.y + canvas.height / 2;
            const worldRight = (canvas.width - canvas.width / 2) / cameraZoom - cameraOffset.x + canvas.width / 2;
            const worldBottom = (canvas.height - canvas.height / 2) / cameraZoom - cameraOffset.y + canvas.height / 2;
            const startX = Math.floor(worldLeft / gridSize) * gridSize;
            const startY = Math.floor(worldTop / gridSize) * gridSize;
            ctx.save();
            ctx.globalAlpha = gridOpacity;
            ctx.beginPath();
            ctx.strokeStyle = gridColor;
            ctx.lineWidth = 1 / cameraZoom;
            for (let x = startX; x < worldRight; x += gridSize) { ctx.moveTo(x, worldTop); ctx.lineTo(x, worldBottom); }
            for (let y = startY; y < worldBottom; y += gridSize) { ctx.moveTo(worldLeft, y); ctx.lineTo(worldRight, y); }
            ctx.stroke();
            ctx.restore();
        }
        
        function drawArrow(context, arrow) {
            const headlen = 10 / cameraZoom;
            const dx = arrow.endX - arrow.startX, dy = arrow.endY - arrow.startY;
            const angle = Math.atan2(dy, dx);
            context.save();
            context.beginPath();
            context.moveTo(arrow.startX, arrow.startY);
            context.lineTo(arrow.endX, arrow.endY);
            context.lineTo(arrow.endX - headlen * Math.cos(angle - Math.PI / 6), arrow.endY - headlen * Math.sin(angle - Math.PI / 6));
            context.moveTo(arrow.endX, arrow.endY);
            context.lineTo(arrow.endX - headlen * Math.cos(angle + Math.PI / 6), arrow.endY - headlen * Math.sin(angle + Math.PI / 6));
            context.strokeStyle = accentColor;
            context.lineWidth = 3 / cameraZoom;
            context.stroke();
            context.restore();
        }

        function drawTextItem(context, item) {
            context.save();
            const centerX = item.x + item.width / 2;
            const centerY = item.y + item.height / 2;
            context.translate(centerX, centerY);
            context.rotate(item.rotation);

            // Draw background
            context.globalAlpha = (item.opacity ?? 1) * 0.05;
            context.fillStyle = accentColor;
            context.fillRect(-item.width / 2, -item.height / 2, item.width, item.height);
            context.globalAlpha = item.opacity ?? 1;

            // Prepare text
            context.fillStyle = accentColor;
            const style = item.fontStyle || 'normal';
            const weight = item.fontWeight || 'bold';
            const family = item.fontFamily || 'Inter';
            context.font = `${style} ${weight} ${item.fontSize}px '${family}', sans-serif`;
            context.textAlign = item.textAlign || 'center';
            context.textBaseline = 'middle';

            const words = item.text.split(' ');
            const lines = [];
            let currentLine = '';
            const padding = 10;
            const maxWidth = item.width - padding * 2;
            
            for (let i = 0; i < words.length; i++) {
                const testLine = currentLine + words[i] + ' ';
                if (context.measureText(testLine).width > maxWidth && i > 0) {
                    lines.push(currentLine.trim());
                    currentLine = words[i] + ' ';
                } else {
                    currentLine = testLine;
                }
            }
            lines.push(currentLine.trim());

            const lineHeight = item.fontSize * 1.4;
            const totalTextHeight = lines.length * lineHeight;
            let startY = -totalTextHeight / 2 + lineHeight / 2;
            
            let textX = 0;
            if (context.textAlign === 'left') {
                textX = -item.width / 2 + padding;
            } else if (context.textAlign === 'right') {
                textX = item.width / 2 - padding;
            }

            lines.forEach((line, index) => {
                context.fillText(line, textX, startY + index * lineHeight);
            });
            
            context.restore();
        }

        function drawBoxItem(context, item) {
            context.save();
            const centerX = item.x + item.width / 2, centerY = item.y + item.height / 2;
            context.translate(centerX, centerY);
            context.rotate(item.rotation);
            
            if (!item.style || item.style === 'fill') {
                context.fillStyle = item.color;
                context.fillRect(-item.width / 2, -item.height / 2, item.width, item.height);
            } else { // 'outline' style
                context.strokeStyle = item.color;
                context.lineWidth = 4 / cameraZoom;
                context.strokeRect(-item.width / 2, -item.height / 2, item.width, item.height);
            }
            
            context.restore();
        }
        
        function drawGridItem(context, item) {
            context.save();
            const centerX = item.x + item.width / 2, centerY = item.y + item.height / 2;
            context.translate(centerX, centerY);
            context.rotate(item.rotation);
            
            context.strokeStyle = item.color;
            context.lineWidth = 2 / cameraZoom;
            
            const cellWidth = item.width / item.cols;
            const cellHeight = item.height / item.rows;
            
            context.beginPath();
            // Vertical lines
            for (let i = 0; i <= item.cols; i++) {
                const x = -item.width / 2 + i * cellWidth;
                context.moveTo(x, -item.height / 2);
                context.lineTo(x, item.height / 2);
            }
            // Horizontal lines
            for (let i = 0; i <= item.rows; i++) {
                const y = -item.height / 2 + i * cellHeight;
                context.moveTo(-item.width / 2, y);
                context.lineTo(item.width / 2, y);
            }
            context.stroke();
            
            context.restore();
        }

        function drawStrokeItem(context, item) {
            if (item.points.length < 2) return;
            context.save();
            context.strokeStyle = item.color;
            context.lineWidth = 4 / cameraZoom;
            context.lineCap = 'round';
            context.lineJoin = 'round';
            context.beginPath();
            context.moveTo(item.points[0].x, item.points[0].y);
            for (let i = 1; i < item.points.length; i++) {
                context.lineTo(item.points[i].x, item.points[i].y);
            }
            context.stroke();
            context.restore();
        }

        function drawGroupItem(context, group) {
            context.save();
            context.globalAlpha *= group.opacity ?? 1;

            // The main draw loop has already applied the group's main transform.
            // We just need to draw the children relative to the group's origin.
            context.translate(group.x, group.y);

            group.items.forEach(item => {
                context.save();
                
                const box = getItemBoundingBox(item);
                const centerX = box.x + box.width / 2;
                const centerY = box.y + box.height / 2;
                
                context.translate(centerX, centerY);
                context.rotate(item.rotation || 0);
                context.scale(item.scaleX || 1, item.scaleY || 1);
                context.translate(-centerX, -centerY);


                // Draw the child item using its own draw function.
                if (item.type === 'image') {
                    if (item.img && item.img.complete) {
                        context.drawImage(item.img, item.x, item.y, item.width, item.height);
                    }
                } else if (item.type === 'arrow') {
                    drawArrow(context, item);
                } else if (item.type === 'text') {
                    drawTextItem(context, item);
                } else if (item.type === 'box') {
                    drawBoxItem(context, item);
                } else if (item.type === 'stroke') {
                    drawStrokeItem(context, item);
                } else if (item.type === 'grid') {
                    drawGridItem(context, item);
                }
                context.restore();
            });

            context.restore();
        }

        // --- EVENT HANDLERS & INPUT ---

        function handleKeyDown(e) {
            const key = e.key.toLowerCase();
            if (currentlyEditingText || document.activeElement === projectNameInput || document.activeElement === gridRowsInput || document.activeElement === gridColsInput) {
                 return;
            }

            if (key === 'escape') {
                e.preventDefault();
                 if (helpModalOverlay.style.display === 'flex') {
                    helpModalOverlay.style.display = 'none';
                    return;
                }
                if (currentTool) {
                    setCurrentTool(null);
                } else if (selectedItems.length > 0) {
                    selectedItems = [];
                    updateSelectionToolbar();
                    updateLeftBarState();
                }
                return;
            }

            // New, Save, Open, and Undo shortcuts
            if (e.shiftKey && key === 'n') { e.preventDefault(); confirmNewBoard(); return; }
            if (e.altKey && key === 'g') { e.preventDefault(); setCurrentTool('grid'); return; }
            
            if (e.ctrlKey) {
                if (e.shiftKey && key === 'z') { e.preventDefault(); redoLastAction(); return; }
                if (e.shiftKey && key === 'g') { e.preventDefault(); ungroupSelectedItems(); return; }
                if (key === 's') { e.preventDefault(); saveProject(); return; }
                if (key === 'o') { e.preventDefault(); projectInput.click(); return; }
                if (key === 'z') { e.preventDefault(); undoLastAction(); return; }
                if (key === 'a' && !e.shiftKey) { e.preventDefault(); selectedItems = [...items]; updateSelectionToolbar(); updateLeftBarState(); return; }
                if (key === 'c') { e.preventDefault(); copyItems(); return; }
                if (key === 'x') { e.preventDefault(); cutItems(); return; }
                if (key === 'v') { e.preventDefault(); pasteItems(); return; }
                if (key === 'd') { e.preventDefault(); duplicateItems(); return; }
                if (key === 'g') { e.preventDefault(); groupSelectedItems(); return; }
            }
            if (e.shiftKey && key === 's') { e.preventDefault(); saveAsPng(); return; }
            if (e.shiftKey && key.toLowerCase() === 'a') {
                e.preventDefault();
                setCurrentTool('arrow');
                return;
            }
            
            // Tool shortcuts
            if (key === 'a' && !e.shiftKey && !e.ctrlKey && !e.altKey) { e.preventDefault(); setCurrentTool(null); return; }
            if (key === 'g' && !e.altKey) { e.preventDefault(); showGrid = !showGrid; showGridToggle.checked = showGrid; return; }
            if (key === 't') { e.preventDefault(); setCurrentTool('text'); return; }
            if (key === 'i') { e.preventDefault(); imageInput.click(); return; }
            if (key === 'b') { e.preventDefault(); setCurrentTool('box'); return; }
            if (key === 'd') { e.preventDefault(); setCurrentTool('draw'); return; }
            if (key === 'e') { e.preventDefault(); setCurrentTool('eyedropper'); return; }

            if (selectedItems.length === 0) return;

            // Layering and Transform shortcuts
            if (key === 'h') { e.preventDefault(); flipHorizontal(); return; }
            if (key === 'v') { e.preventDefault(); flipVertical(); return; }
            if (key === 'home') { e.preventDefault(); bringSelectedToFront(); return; }
            if (key === 'end') { e.preventDefault(); sendSelectedToBack(); return; }
            if (key === 'pageup') { e.preventDefault(); moveSelectedUp(); return; }
            if (key === 'pagedown') { e.preventDefault(); moveSelectedDown(); return; }
            
            if (key === 'delete' || key === 'backspace') { e.preventDefault(); deleteSelectedItems(); return; }
            
            if(selectedItems.length !== 1) return;
            const selectedItem = selectedItems[0];
            e.preventDefault();
            if (key === 'p') { togglePin(); return; }
            if (selectedItem.isPinned) return;
            switch (key) {
                case 'r': setActiveGizmo('rotate'); break;
                case 's': setActiveGizmo('scale'); break;
            }
        }

        function onDoubleClick(e) {
            const worldPos = screenToWorld(getEventLocation(e));
            const item = getItemAtPosition(worldPos);
            if (item && item.type === 'text' && !item.isPinned) editText(item);
        }

        function onMouseDown(e) {
            if (currentlyEditingText) { finishEditingText(); return; }
            const screenPos = getEventLocation(e);
            const worldPos = screenToWorld(screenPos);

            if (currentTool === 'eyedropper') {
                const pixel = ctx.getImageData(screenPos.x, screenPos.y, 1, 1).data;
                const hexColor = rgbToHex(pixel[0], pixel[1], pixel[2]);
                accentColor = hexColor;
                updateUIColors();
                setCurrentTool(null);
                return;
            }

            // Left click
            if (e.button === 0) {
                // Check for gizmo/handle interaction first
                if (selectedItems.length === 1) {
                    if (selectedItems[0].type === 'arrow' && !selectedItems[0].isPinned) {
                        const handle = getArrowHandleAtPosition(worldPos);
                        if (handle) { isTransformingArrow = true; transformingHandle = handle; return; }
                    }
                    const gizmo = getGizmoAtPosition(worldPos);
                    if (gizmo && !selectedItems[0].isPinned) {
                        isTransforming = true;
                        const itemToTransform = selectedItems[0];
                        
                        originalItemState = JSON.parse(JSON.stringify(itemToTransform));
                        reattachImages(itemToTransform, originalItemState);
                        
                        originalItemState.centerX = itemToTransform.x + itemToTransform.width / 2;
                        originalItemState.centerY = itemToTransform.y + itemToTransform.height / 2;
                        originalItemState.startAngle = Math.atan2(worldPos.y - originalItemState.centerY, worldPos.x - originalItemState.centerX);
                        originalItemState.startDist = Math.hypot(worldPos.x - originalItemState.centerY, worldPos.y - originalItemState.centerX);

                        // Calculate and store the pivot point (opposite corner) for scaling
                        if (gizmo === 'scale') {
                            const pivotLocal = { x: -originalItemState.width / 2, y: -originalItemState.height / 2 };
                            const cos = Math.cos(originalItemState.rotation);
                            const sin = Math.sin(originalItemState.rotation);
                            const pivotWorldX = pivotLocal.x * cos - pivotLocal.y * sin + originalItemState.centerX;
                            const pivotWorldY = pivotLocal.x * sin + pivotLocal.y * cos + originalItemState.centerY;
                            originalItemState.pivot = { x: pivotWorldX, y: pivotWorldY };
                        }

                        return;
                    }
                }
                
                // If using a tool, start drawing
                if(currentTool) {
                    isDrawing = true;
                    let newItem;
                    if(currentTool === 'arrow') {
                        newItem = { id: Date.now(), type: 'arrow', startX: worldPos.x, startY: worldPos.y, endX: worldPos.x, endY: worldPos.y, rotation: 0, isPinned: false, x: worldPos.x, y: worldPos.y, width: 0, height: 0, opacity: 1, scaleX: 1, scaleY: 1 };
                    } else if (currentTool === 'text') {
                        newItem = { id: Date.now(), type: 'text', text: 'Type...', x: worldPos.x, y: worldPos.y, width: 0, height: 0, fontSize: 32, rotation: 0, isPinned: false, opacity: 1, fontFamily: 'Inter', textAlign: 'center', fontWeight: 'bold', fontStyle: 'normal', scaleX: 1, scaleY: 1 };
                    } else if (currentTool === 'box') {
                        newItem = { id: Date.now(), type: 'box', color: accentColor, x: worldPos.x, y: worldPos.y, width: 0, height: 0, rotation: 0, isPinned: false, style: 'fill', opacity: 1, scaleX: 1, scaleY: 1 };
                    } else if (currentTool === 'grid') {
                        newItem = { id: Date.now(), type: 'grid', color: accentColor, x: worldPos.x, y: worldPos.y, width: 0, height: 0, rotation: 0, isPinned: false, opacity: 1, rows: 3, cols: 3, scaleX: 1, scaleY: 1 };
                    } else if (currentTool === 'draw') {
                        newItem = { id: Date.now(), type: 'stroke', points: [{x: worldPos.x, y: worldPos.y}], color: accentColor, isPinned: false, x: worldPos.x, y: worldPos.y, width: 0, height: 0, opacity: 1, scaleX: 1, scaleY: 1 };
                    }
                    items.push(newItem);
                    selectedItems = [newItem];
                    bringSelectedToFront(); // New items on top
                } else {
                    const newSelectedItem = getItemAtPosition(worldPos);
                    // Shift-click to add/remove from selection
                    if (e.shiftKey) {
                         if (newSelectedItem) {
                            const index = selectedItems.findIndex(item => item.id === newSelectedItem.id);
                            if (index > -1) selectedItems.splice(index, 1); 
                            else selectedItems.push(newSelectedItem);
                        }
                    } else {
                        // FIX: Unified movement/selection logic
                        if (newSelectedItem) {
                            if (!selectedItems.includes(newSelectedItem)) {
                                selectedItems = [newSelectedItem];
                            }
                            isMovingItems = true;
                            moveStart.x = worldPos.x;
                            moveStart.y = worldPos.y;
                            selectedItems.forEach(item => {
                                item.originalX = item.x; item.originalY = item.y;
                                if (item.type === 'arrow'){ 
                                    item.originalStartX = item.startX; item.originalStartY = item.startY; 
                                    item.originalEndX = item.endX; item.originalEndY = item.endY; 
                                } else if (item.type === 'stroke') {
                                    item.originalPoints = JSON.parse(JSON.stringify(item.points));
                                } else if (item.type === 'group') {
                                    item.originalItems = JSON.parse(JSON.stringify(item.items));
                                    reattachImages(item, {items: item.originalItems}); // Reattach to the clone
                                }
                            });
                        } else {
                            // Clicked on empty space, start selection box
                            selectedItems = [];
                            isSelectingBox = true;
                            selectionBox.startX = worldPos.x; selectionBox.startY = worldPos.y;
                            selectionBox.endX = worldPos.x; selectionBox.endY = worldPos.y;
                        }
                    }
                    updateSelectionToolbar();
                    updateLeftBarState();
                }
            } 
            // Middle click to pan
            else if (e.button === 1) {
                isDragging = true; 
                dragStart.x = getEventLocation(e).x / cameraZoom - cameraOffset.x; 
                dragStart.y = getEventLocation(e).y / cameraZoom - cameraOffset.y; 
                canvas.classList.add('grabbing');
            }
        }

        function onMouseUp(e) {
            if (e.button === 0) {
                // If any action was taken that modifies items, save state for undo
                if (isDrawing || isMovingItems || isTransforming || isTransformingArrow) {
                    if (isDrawing) {
                        const item = selectedItems[0];
                        if (item && (item.type === 'text' || item.type === 'box' || item.type === 'grid') && (item.width < 10 || item.height < 10)) {
                             items = items.filter(i => i.id !== item.id);
                             selectedItems = [];
                        } else if (item && item.type === 'text') {
                            editText(item);
                        }
                    }
                    saveStateForUndo();
                }

                // Finalize selection box
                if (isSelectingBox) {
                    isSelectingBox = false;
                    const box = getNormalizedSelectionBox();
                    selectedItems = items.filter(item => rectsIntersect(getItemBoundingBox(item), box));
                    updateSelectionToolbar();
                    updateLeftBarState();
                }

                // Reset states
                isDrawing = false; isMovingItems = false; isTransforming = false; isTransformingArrow = false;
                transformingHandle = null; originalItemState = null;
                // setCurrentTool(null); // REMOVED to keep tool active
            } else if (e.button === 1) { 
                isDragging = false; 
                canvas.classList.remove('grabbing'); 
            }
        }

        function onMouseMove(e) {
            const worldPos = screenToWorld(getEventLocation(e));
            
            // Update selection box
            if(isSelectingBox){ selectionBox.endX = worldPos.x; selectionBox.endY = worldPos.y; return; }

            // Handle arrow transformations
            if (isTransformingArrow && selectedItems.length === 1) {
                const selectedItem = selectedItems[0];
                if (transformingHandle === 'start') { selectedItem.startX = worldPos.x; selectedItem.startY = worldPos.y; } 
                else if (transformingHandle === 'end') { selectedItem.endX = worldPos.x; selectedItem.endY = worldPos.y; }
                return;
            }

            // Handle item transformations (scale/rotate)
            if (isTransforming && selectedItems.length === 1) {
                const selectedItem = selectedItems[0];
                const centerX = originalItemState.centerX, centerY = originalItemState.centerY;
                if (activeGizmo === 'rotate') {
                    const currentAngle = Math.atan2(worldPos.y - centerY, worldPos.x - centerX);
                    let newRotation = originalItemState.rotation + (currentAngle - originalItemState.startAngle);
                    if (e.shiftKey) newRotation = Math.round(newRotation / (Math.PI / 12)) * (Math.PI / 12);
                    selectedItem.rotation = newRotation;
                } else if (activeGizmo === 'scale') {
                    let scaleFactor = 1;
                    // SHIFT key is pressed: scale from top-left pivot
                    if (e.shiftKey) {
                        const pivot = originalItemState.pivot;
                        const vecWorld = { x: worldPos.x - pivot.x, y: worldPos.y - pivot.y };
                        const origHandleLocal = { x: originalItemState.width / 2, y: originalItemState.height / 2 };
                        const cos = Math.cos(originalItemState.rotation);
                        const sin = Math.sin(originalItemState.rotation);
                        const origHandleWorldOffsetX = origHandleLocal.x * cos - origHandleLocal.y * sin;
                        const origHandleWorldOffsetY = origHandleLocal.x * sin + origHandleLocal.y * cos;
                        const origDiagVec = { x: origHandleWorldOffsetX * 2, y: origHandleWorldOffsetY * 2 };
                        const projectionLength = (vecWorld.x * origDiagVec.x + vecWorld.y * origDiagVec.y) / Math.hypot(origDiagVec.x, origDiagVec.y);
                        const originalDiagonalLength = Math.hypot(originalItemState.width, originalItemState.height);
                        scaleFactor = projectionLength / originalDiagonalLength;

                        if (scaleFactor > 0.05) { // Prevent inverting the item
                            const newWidth = originalItemState.width * scaleFactor;
                            const newHeight = originalItemState.height * scaleFactor;
                            const newCenterX = pivot.x + (origDiagVec.x / 2) * scaleFactor;
                            const newCenterY = pivot.y + (origDiagVec.y / 2) * scaleFactor;
                            
                            selectedItem.width = newWidth;
                            selectedItem.height = newHeight;
                            selectedItem.x = newCenterX - newWidth / 2;
                            selectedItem.y = newCenterY - newHeight / 2;
                        }

                    } else { // Default behavior: scale from center
                        const currentDist = Math.hypot(worldPos.x - centerX, worldPos.y - centerY);
                        scaleFactor = Math.max(0.1, currentDist / originalItemState.startDist);
                        selectedItem.width = originalItemState.width * scaleFactor;
                        selectedItem.height = originalItemState.height * scaleFactor;
                        selectedItem.x = centerX - selectedItem.width / 2;
                        selectedItem.y = centerY - selectedItem.height / 2;
                    }

                    // After scaling the item container, scale its contents
                    if (selectedItem.type === 'group') {
                        const oldWidth = originalItemState.width;
                        const oldHeight = originalItemState.height;
                        const scaleX = selectedItem.width / oldWidth;
                        const scaleY = selectedItem.height / oldHeight;

                        if (isFinite(scaleX) && isFinite(scaleY)) {
                            selectedItem.items.forEach((child, index) => {
                                const originalChild = originalItemState.items[index];
                                child.x = originalChild.x * scaleX;
                                child.y = originalChild.y * scaleY;
                                child.width = originalChild.width * scaleX;
                                child.height = originalChild.height * scaleY;

                                if (child.type === 'text') {
                                    child.fontSize = originalChild.fontSize * Math.min(scaleX, scaleY);
                                } else if (child.type === 'arrow') {
                                    child.startX = originalChild.startX * scaleX; child.startY = originalChild.startY * scaleY;
                                    child.endX = originalChild.endX * scaleX; child.endY = originalChild.endY * scaleY;
                                } else if (child.type === 'stroke') {
                                    child.points = originalChild.points.map(p => ({ x: p.x * scaleX, y: p.y * scaleY }));
                                }
                            });
                        }
                    } else if (selectedItem.type === 'text') {
                        selectedItem.fontSize = originalItemState.fontSize * scaleFactor;
                    }
                }
            } 
            // Handle item movement
            else if (isMovingItems && selectedItems.length > 0) {
                 const dx = worldPos.x - moveStart.x;
                 const dy = worldPos.y - moveStart.y;
                 const currentSnap = e.shiftKey ? !snapToGrid : snapToGrid;

                selectedItems.forEach(item => {
                    if (item.isPinned) return;
                    
                    let finalDx = dx;
                    let finalDy = dy;

                    if (currentSnap && selectedItems.length === 1) {
                        const snappedX = Math.round((item.originalX + dx) / gridSize) * gridSize;
                        const snappedY = Math.round((item.originalY + dy) / gridSize) * gridSize;
                        finalDx = snappedX - item.originalX;
                        finalDy = snappedY - item.originalY;
                    }

                    item.x = item.originalX + finalDx;
                    item.y = item.originalY + finalDy;

                    if (item.type === 'arrow') {
                        item.startX = item.originalStartX + finalDx;
                        item.startY = item.originalStartY + finalDy;
                        item.endX = item.originalEndX + finalDx;
                        item.endY = item.originalEndY + finalDy;
                    } else if (item.type === 'stroke') {
                        item.points = item.originalPoints.map(p => ({
                            x: p.x + finalDx,
                            y: p.y + finalDy
                        }));
                    }
                });
            } 
            // Handle drawing new items
            else if (isDrawing && selectedItems.length === 1) {
                const selectedItem = selectedItems[0];
                 if(selectedItem.type === 'arrow') {
                    selectedItem.endX = worldPos.x;
                    selectedItem.endY = worldPos.y;
                } else if(selectedItem.type === 'text' || selectedItem.type === 'box' || selectedItem.type === 'grid') {
                    selectedItem.width = Math.abs(worldPos.x - selectedItem.x);
                    selectedItem.height = Math.abs(worldPos.y - selectedItem.y);
                    selectedItem.x = Math.min(worldPos.x, selectedItem.x);
                    selectedItem.y = Math.min(worldPos.y, selectedItem.y);
                } else if (selectedItem.type === 'stroke') {
                    selectedItem.points.push({x: worldPos.x, y: worldPos.y});
                    const box = getItemBoundingBox(selectedItem);
                    selectedItem.x = box.x;
                    selectedItem.y = box.y;
                    selectedItem.width = box.width;
                    selectedItem.height = box.height;
                }
            } 
            // Handle camera panning
            else if (isDragging) {
                cameraOffset.x = getEventLocation(e).x / cameraZoom - dragStart.x; 
                cameraOffset.y = getEventLocation(e).y / cameraZoom - dragStart.y;
            }

            // Update cursor style based on context
            if (!isDragging && !isMovingItems && !isTransforming && !isTransformingArrow) {
                const currentHoveredGizmo = getGizmoAtPosition(worldPos);
                const currentHoveredArrowHandle = getArrowHandleAtPosition(worldPos);
                if (currentHoveredGizmo !== hoveredGizmo || currentHoveredArrowHandle !== hoveredArrowHandle) {
                    hoveredGizmo = currentHoveredGizmo;
                    hoveredArrowHandle = currentHoveredArrowHandle;
                }
                if (hoveredGizmo || hoveredArrowHandle) canvas.style.cursor = 'pointer';
                else if (getItemAtPosition(worldPos)) canvas.style.cursor = 'move';
                else if (currentTool) canvas.style.cursor = 'crosshair';
                else canvas.style.cursor = 'grab';
            }
        }
        
        function onContextMenu(e) {
            e.preventDefault();
            const itemUnderCursor = getItemAtPosition(screenToWorld(getEventLocation(e)));
            if (itemUnderCursor && !selectedItems.includes(itemUnderCursor)) {
                selectedItems = [itemUnderCursor]; 
                updateSelectionToolbar();
                updateLeftBarState();
            }

            if (selectedItems.length > 0) {
                opacitySliderContainer.style.display = 'flex';
                opacitySeparator.style.display = 'block';
                const referenceOpacity = selectedItems[0].opacity ?? 1;
                itemOpacitySlider.value = referenceOpacity;
                itemOpacityValue.textContent = `${Math.round(referenceOpacity * 100)}%`;
                deleteItemBtn.style.display = 'flex';
                document.getElementById('delete-separator').style.display = 'block';
            } else {
                opacitySliderContainer.style.display = 'none';
                opacitySeparator.style.display = 'none';
                deleteItemBtn.style.display = 'none';
                document.getElementById('delete-separator').style.display = 'none';
            }

            const isSingleImageSelected = selectedItems.length === 1 && selectedItems[0].type === 'image';
            downloadImageBtn.style.display = isSingleImageSelected ? 'flex' : 'none';
            downloadSeparator.style.display = isSingleImageSelected ? 'block' : 'none';

            contextMenu.style.left = `${e.clientX}px`; 
            contextMenu.style.top = `${e.clientY}px`; 
            contextMenu.style.display = 'block';
        }

        // --- FILE & PROJECT HANDLING ---

        function confirmNewBoard() {
            if (items.length > 0) {
                showConfirmationModal();
            } else {
                resetBoard();
            }
        }

        function resetBoard() {
            items = [];
            selectedItems = [];
            cameraOffset = { x: window.innerWidth / 2, y: window.innerHeight / 2 };
            cameraZoom = 1;
            historyStack = [];
            historyIndex = -1;
            saveStateForUndo(); // Save the new empty state
            currentProjectName = 'moodboard';
            projectNameInput.value = currentProjectName;
            updateSelectionToolbar();
            updateLeftBarState();
        }

        function showConfirmationModal() {
            confirmationModalOverlay.style.display = 'flex';
        }

        function hideConfirmationModal() {
            confirmationModalOverlay.style.display = 'none';
        }

        function saveAsPng() {
            if (items.length === 0) {
                showToast("Board is empty, nothing to export.", "error");
                return;
            }
            let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
            items.forEach(item => {
                const box = getItemBoundingBox(item);
                minX = Math.min(minX, box.x); minY = Math.min(minY, box.y);
                maxX = Math.max(maxX, box.x + box.width); maxY = Math.max(maxY, box.y + box.height);
            });
            const padding = 50;
            const exportWidth = maxX - minX + padding * 2;
            const exportHeight = maxY - minY + padding * 2;
            const exportCanvas = document.createElement('canvas');
            exportCanvas.width = exportWidth; exportCanvas.height = exportHeight;
            const exportCtx = exportCanvas.getContext('2d');
            exportCtx.fillStyle = canvasBackgroundColor;
            exportCtx.fillRect(0, 0, exportWidth, exportHeight);
            exportCtx.translate(-minX + padding, -minY + padding);
            items.forEach(item => {
                exportCtx.save();
                exportCtx.globalAlpha = item.opacity ?? 1;
                if (showDropShadow) { exportCtx.shadowColor = 'rgba(0,0,0,0.4)'; exportCtx.shadowBlur = 15; exportCtx.shadowOffsetX = 4; exportCtx.shadowOffsetY = 4; }
                if (item.type === 'image') {
                    const centerX = item.x + item.width / 2, centerY = item.y + item.height / 2;
                    exportCtx.translate(centerX, centerY); exportCtx.rotate(item.rotation); exportCtx.translate(-centerX, -centerY);
                    exportCtx.drawImage(item.img, item.x, item.y, item.width, item.height);
                } else if (item.type === 'arrow') {
                    drawArrow(exportCtx, item);
                } else if (item.type === 'text') {
                    drawTextItem(exportCtx, item);
                } else if (item.type === 'box') {
                    drawBoxItem(exportCtx, item);
                } else if (item.type === 'stroke') {
                    drawStrokeItem(exportCtx, item);
                } else if (item.type === 'grid') {
                    drawGridItem(exportCtx, item);
                } else if (item.type === 'group') {
                    drawGroupItem(exportCtx, item);
                }
                exportCtx.restore();
            });
            const link = document.createElement('a');
            link.download = 'moodboard.png';
            link.href = exportCanvas.toDataURL('image/png');
            link.click();
            showToast("Image exported as PNG.");
        }

        function saveProject() {
            const projectState = {
                items: items.map(item => {
                    const serializableItem = { ...item };
                    if (item.type === 'image') {
                        serializableItem.img = item.img.src;
                    } else if (item.type === 'group') {
                        serializableItem.items = item.items.map(child => {
                            if (child.type === 'image') return { ...child, img: child.img.src };
                            return child;
                        });
                    }
                    return serializableItem;
                }),
                cameraOffset, cameraZoom, canvasBackgroundColor, accentColor, gridColor,
                showGrid, snapToGrid, showDropShadow, gridSize, gridOpacity
            };
            const blob = new Blob([JSON.stringify(projectState, null, 2)], { type: 'application/json' });
            const link = document.createElement('a');
            link.href = URL.createObjectURL(blob);
            link.download = `${currentProjectName}.json`;
            link.click();
            URL.revokeObjectURL(link.href);
            showToast("Project saved successfully.");
        }

        function loadProject(projectJson) {
            try {
                const state = JSON.parse(projectJson);
                cameraOffset = state.cameraOffset;
                cameraZoom = state.cameraZoom;
                canvasBackgroundColor = state.canvasBackgroundColor;
                accentColor = state.accentColor;
                gridColor = state.gridColor;
                showGrid = state.showGrid;
                snapToGrid = state.snapToGrid;
                showDropShadow = state.showDropShadow;
                gridSize = state.gridSize;
                gridOpacity = state.gridOpacity;
                
                items = [];
                selectedItems = [];
                
                // Recreate items, especially Image objects
                const recreateItems = (itemList) => {
                    return itemList.map(itemState => {
                        const newItem = { ...(itemState.opacity !== undefined ? {} : { opacity: 1 }), ...itemState };
                        if (newItem.type === 'image') {
                            const img = new Image();
                            newItem.img = img;
                            img.src = itemState.img;
                        } else if (newItem.type === 'group') {
                            newItem.items = recreateItems(newItem.items);
                        }
                        return newItem;
                    });
                };
                items = recreateItems(state.items);
                
                // Update UI to reflect loaded settings
                historyStack = [];
                historyIndex = -1;
                updateUIColors();
                saveStateForUndo(); // Save this loaded state as the first undo point
                showToast("Project loaded successfully.");

            } catch (error) {
                console.error("Failed to load project:", error);
                showToast("Failed to load project. Invalid file.", "error");
            }
        }

        function handleImageUpload(event) {
            if (!event.target.files) return;
            const worldPos = screenToWorld({x: canvas.width / 2, y: canvas.height / 2});
            processFiles(event.target.files, worldPos);
            imageInput.value = '';
        }

        function handleProjectUpload(event) {
            const file = event.target.files[0];
            if (!file) return;
            const reader = new FileReader();
            reader.onload = (e) => {
                loadProject(e.target.result);
                currentProjectName = file.name.split('.').slice(0, -1).join('.');
                projectNameInput.value = currentProjectName;
            };
            reader.readAsText(file);
            projectInput.value = '';
        }

        function handlePaste(e) {
            const files = Array.from(e.clipboardData.items)
                .filter(item => item.type.indexOf('image') !== -1)
                .map(item => item.getAsFile());
            if (files.length > 0) processFiles(files, screenToWorld({ x: canvas.width / 2, y: canvas.height / 2 }));
        }
        function handleDragOver(e) { e.preventDefault(); canvas.style.outline = `2px dashed ${accentColor}`; canvas.style.outlineOffset = '-10px'; }
        function handleDragLeave(e) { e.preventDefault(); canvas.style.outline = 'none'; }
        
        function handleDrop(e) {
            e.preventDefault();
            handleDragLeave(e);
            if (!e.dataTransfer.files) return;
            
            const file = e.dataTransfer.files[0];
            if (file && (file.name.endsWith('.json') || file.name.endsWith('.mood'))) {
                 const reader = new FileReader();
                 reader.onload = (ev) => {
                    loadProject(ev.target.result);
                    currentProjectName = file.name.split('.').slice(0, -1).join('.');
                    projectNameInput.value = currentProjectName;
                 };
                 reader.readAsText(file);
            } else {
                 processFiles(e.dataTransfer.files, screenToWorld({ x: e.clientX, y: e.clientY }));
            }
        }

        function processFiles(files, worldPos) {
             Array.from(files).forEach((file, index) => {
                if (!file.type.startsWith('image/')) return;
                const reader = new FileReader();
                reader.onload = (e) => {
                    const img = new Image();
                    img.onload = () => {
                        const aspectRatio = img.width / img.height; 
                        const newWidth = 250, newHeight = newWidth / aspectRatio;
                        items.push({ id: Date.now() + index, type: 'image', img: img, x: worldPos.x - (newWidth / 2) + (index * 20), y: worldPos.y - (newHeight / 2) + (index * 20), width: newWidth, height: newHeight, rotation: 0, isPinned: false, opacity: 1, scaleX: 1, scaleY: 1 });
                        bringSelectedToFront();
                    };
                    img.src = e.target.result;
                };
                reader.readAsDataURL(file);
            });
            setTimeout(saveStateForUndo, 500); // Wait for images to likely have loaded
        }

        function downloadSourceImage() {
            if (selectedItems.length !== 1 || selectedItems[0].type !== 'image') return;

            const item = selectedItems[0];
            const link = document.createElement('a');
            link.href = item.img.src;

            try {
                const url = new URL(item.img.src);
                const pathnameParts = url.pathname.split('/');
                link.download = pathnameParts[pathnameParts.length - 1] || 'source_image';
            } catch (e) {
                link.download = 'source_image.png';
            }
            
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
            showToast("Source image download started.");
        }

        // --- CLIPBOARD FUNCTIONS ---

        function copyItems(showNotification = true) {
            if (selectedItems.length === 0) return;
            clipboard = selectedItems.map(item => {
                const copy = JSON.parse(JSON.stringify(item));
                // Handle non-serializable data
                if (item.type === 'image') {
                    copy.imgSrc = item.img.src;
                    delete copy.img;
                } else if (item.type === 'group') {
                    item.items.forEach((child, i) => {
                         if (child.type === 'image') {
                            copy.items[i].imgSrc = child.img.src;
                            delete copy.items[i].img;
                        }
                    });
                }
                return copy;
            });
            if (showNotification) {
                showToast(`${selectedItems.length} item${selectedItems.length > 1 ? 's' : ''} copied.`);
            }
        }

        function cutItems() {
            if (selectedItems.length === 0) return;
            copyItems(false);
            const cutCount = clipboard.length;
            deleteSelectedItems();
            showToast(`${cutCount} item${cutCount > 1 ? 's' : ''} cut to clipboard.`);
        }

        function pasteItems() {
            if (clipboard.length === 0) {
                showToast("Clipboard is empty.", "error");
                return;
            }
            
            const newItems = [];
            const pasteOffset = 20 / cameraZoom;

            const recreateItemFromClipboard = (clipboardItem) => {
                 const newItem = JSON.parse(JSON.stringify(clipboardItem));
                newItem.id = Date.now() + Math.random();
                newItem.isPinned = false; // Always paste as unpinned
                
                // Recursive function to restore images from imgSrc
                function restoreImages(item) {
                    if (item.type === 'image') {
                        const img = new Image();
                        img.src = item.imgSrc;
                        delete item.imgSrc;
                        item.img = img;
                    } else if (item.type === 'group') {
                        item.items.forEach(restoreImages); // Recurse through children
                    }
                }

                restoreImages(newItem);

                // Adjust coordinates for the top-level item
                newItem.x += pasteOffset;
                newItem.y += pasteOffset;

                if (newItem.type === 'arrow') {
                    newItem.startX += pasteOffset;
                    newItem.startY += pasteOffset;
                    newItem.endX += pasteOffset;
                    newItem.endY += pasteOffset;
                } else if (newItem.type === 'stroke') {
                    newItem.points.forEach(p => { p.x += pasteOffset; p.y += pasteOffset; });
                }
                
                return newItem;
            }

            clipboard.forEach(clipboardItem => {
                const newItem = recreateItemFromClipboard(clipboardItem);
                items.push(newItem);
                newItems.push(newItem);
            });

            selectedItems = newItems;
            updateSelectionToolbar();
            updateLeftBarState();
            saveStateForUndo();
            showToast(`${newItems.length} item${newItems.length > 1 ? 's' : ''} pasted.`);
        }

        function duplicateItems() {
            if (selectedItems.length === 0) return;

            const itemsToDuplicate = selectedItems;
            const newItems = [];
            const duplicateOffset = 20 / cameraZoom;

            itemsToDuplicate.forEach(item => {
                const newItem = JSON.parse(JSON.stringify(item));
                
                // Recursively re-attach the original img objects
                reattachImages(item, newItem);
                
                newItem.id = Date.now() + Math.random();
                newItem.isPinned = false; // Always duplicate as unpinned
                newItem.x += duplicateOffset;
                newItem.y += duplicateOffset;

                if (newItem.type === 'arrow') {
                    newItem.startX += duplicateOffset;
                    newItem.startY += duplicateOffset;
                    newItem.endX += duplicateOffset;
                    newItem.endY += duplicateOffset;
                } else if (newItem.type === 'stroke') {
                    newItem.points.forEach(p => { p.x += duplicateOffset; p.y += duplicateOffset; });
                }
                // Image objects are now handled recursively by reattachImages

                items.push(newItem);
                newItems.push(newItem);
            });

            selectedItems = newItems;
            updateSelectionToolbar();
            updateLeftBarState();
            saveStateForUndo();
            showToast(`${newItems.length} item${newItems.length > 1 ? 's' : ''} duplicated.`);
        }


        // --- ITEM & SELECTION LOGIC ---

        function deleteSelectedItems() {
            if(selectedItems.length > 0) {
                const idsToDelete = new Set(selectedItems.map(item => item.id));
                items = items.filter(item => !idsToDelete.has(item.id));
                selectedItems = [];
                updateSelectionToolbar();
                updateLeftBarState();
                saveStateForUndo();
            }
        }
        
        function bringSelectedToFront() {
            if (selectedItems.length === 0) return;
            const selectedIds = new Set(selectedItems.map(item => item.id));
            const toFront = items.filter(item => selectedIds.has(item.id));
            const remaining = items.filter(item => !selectedIds.has(item.id));
            items = [...remaining, ...toFront];
            saveStateForUndo();
        }

        function sendSelectedToBack() {
            if (selectedItems.length === 0) return;
            const selectedIds = new Set(selectedItems.map(item => item.id));
            const toBack = items.filter(item => selectedIds.has(item.id));
            const remaining = items.filter(item => !selectedIds.has(item.id));
            items = [...toBack, ...remaining];
            saveStateForUndo();
        }
        
        function moveSelectedUp() {
            if (selectedItems.length !== 1) return;
            const selectedItem = selectedItems[0];
            const index = items.findIndex(item => item.id === selectedItem.id);
            if (index > -1 && index < items.length - 1) {
                [items[index], items[index + 1]] = [items[index + 1], items[index]];
                saveStateForUndo();
            }
        }

        function moveSelectedDown() {
            if (selectedItems.length !== 1) return;
            const selectedItem = selectedItems[0];
            const index = items.findIndex(item => item.id === selectedItem.id);
            if (index > 0) {
                [items[index], items[index - 1]] = [items[index - 1], items[index]];
                saveStateForUndo();
            }
        }

        function toggleBoxStyle() {
            let changed = false;
            selectedItems.forEach(item => {
                if (item.type === 'box') {
                    item.style = item.style === 'fill' ? 'outline' : 'fill';
                    changed = true;
                }
            });
            if (changed) {
                saveStateForUndo();
            }
        }

        function autoAlignSelection() {
            if (selectedItems.length < 2) return;

            const padding = 20;

            let totalWidth = 0, totalHeight = 0;
            selectedItems.forEach(item => {
                totalWidth += getItemBoundingBox(item).width;
                totalHeight += getItemBoundingBox(item).height;
            });
            const avgWidth = totalWidth / selectedItems.length;
            const avgHeight = totalHeight / selectedItems.length;
            
            const numCols = Math.ceil(Math.sqrt(selectedItems.length));
            const collectiveBox = getCollectiveBoundingBox(selectedItems);
            const startX = collectiveBox.x;
            const startY = collectiveBox.y;

            selectedItems.forEach((item, index) => {
                const row = Math.floor(index / numCols);
                const col = index % numCols;

                const newX = startX + col * (avgWidth + padding);
                const newY = startY + row * (avgHeight + padding);
                
                const deltaX = newX - item.x;
                const deltaY = newY - item.y;
                
                item.x += deltaX;
                item.y += deltaY;

                if (item.type === 'arrow') {
                    item.startX += deltaX;
                    item.startY += deltaY;
                    item.endX += deltaX;
                    item.endY += deltaY;
                } else if (item.type === 'stroke') {
                    item.points.forEach(p => {
                        p.x += deltaX;
                        p.y += deltaY;
                    });
                } else if (item.type === 'group') {
                    // Moving a group moves its children implicitly
                }
            });
            saveStateForUndo();
        }


        // --- UI & STATE MANAGEMENT ---

        function updateLeftBarState() {
            alignBtn.disabled = selectedItems.length < 2;
        }

        function updateUIColors() {
            const rootStyle = document.documentElement.style;

            // --- NEW GLASS UI VALUES ---
            const uiBgColor = 'rgba(35, 38, 51, 0.4)'; // A dark, slightly transparent background
            const uiBgHoverColor = 'rgba(55, 58, 71, 0.5)';
            const textColor = '#e2e8f0'; // A light grey/off-white
            const textLightColor = '#94a3b8'; // A dimmer grey for secondary text
            const borderColor = 'rgba(255, 255, 255, 0.1)'; // A very subtle white border

            rootStyle.setProperty('--bg-page', canvasBackgroundColor);
            rootStyle.setProperty('--bg-ui', uiBgColor);
            rootStyle.setProperty('--bg-ui-hover', uiBgHoverColor);
            rootStyle.setProperty('--text-color', textColor);
            rootStyle.setProperty('--text-color-light', textLightColor);
            rootStyle.setProperty('--text-color-strong', '#ffffff');
            rootStyle.setProperty('--border-color', borderColor);
            rootStyle.setProperty('--switch-bg-checked', accentColor);

            // Sync UI controls with state
            canvas.style.backgroundColor = canvasBackgroundColor;
            bgColorPicker.value = canvasBackgroundColor;
            accentColorPicker.value = accentColor;
            toolbarAccentColorPicker.value = accentColor;
            gridColorPicker.value = gridColor;
        }

        function setCurrentTool(tool) {
            if (currentTool === tool && tool !== null) { // allow deselecting to null
                return;
            }
             currentTool = tool;

            document.querySelectorAll('#left-bar .tool-button').forEach(btn => btn.classList.remove('active'));
            canvas.classList.remove('eyedropper-active');

            if (currentTool === null) {
                selectToolBtn.classList.add('active');
            } else if (currentTool === 'arrow') {
                addArrowBtn.classList.add('active');
            } else if (currentTool === 'text') {
                addTextBtn.classList.add('active');
            } else if (currentTool === 'box') {
                addBoxBtn.classList.add('active');
            } else if (currentTool === 'grid') {
                addGridBtn.classList.add('active');
            } else if (currentTool === 'draw') {
                drawBtn.classList.add('active');
            } else if (currentTool === 'eyedropper') {
                eyedropperBtn.classList.add('active');
                canvas.classList.add('eyedropper-active');
            }
        }

        function setActiveGizmo(gizmo) { 
            activeGizmo = activeGizmo === gizmo ? null : gizmo; 
            updateSelectionToolbar(); 
        }
        function togglePin() { 
            if (selectedItems.length > 0) { 
                const newState = !selectedItems[0].isPinned;
                selectedItems.forEach(item => item.isPinned = newState);
                updateSelectionToolbar(); 
                saveStateForUndo();
            } 
        }

        function setTextAlign(align) {
            if (selectedItems.length === 1 && selectedItems[0].type === 'text') {
                selectedItems[0].textAlign = align;
                updateSelectionToolbar();
                saveStateForUndo();
            }
        }
        
        function updateGridDimension(dimension, value) {
            if (selectedItems.length === 1 && selectedItems[0].type === 'grid') {
                const item = selectedItems[0];
                const intValue = parseInt(value, 10);
                if (intValue > 0) {
                    item[dimension] = intValue;
                    saveStateForUndo();
                }
            }
        }

        function setTextFontFamily(e) {
            if (selectedItems.length === 1 && selectedItems[0].type === 'text') {
                selectedItems[0].fontFamily = e.target.value;
                saveStateForUndo();
            }
        }

        function toggleTextStyleBold() {
            if (selectedItems.length === 1 && selectedItems[0].type === 'text') {
                const item = selectedItems[0];
                item.fontWeight = item.fontWeight === 'bold' ? 'normal' : 'bold';
                updateSelectionToolbar();
                saveStateForUndo();
            }
        }

        function toggleTextStyleItalic() {
            if (selectedItems.length === 1 && selectedItems[0].type === 'text') {
                const item = selectedItems[0];
                item.fontStyle = item.fontStyle === 'italic' ? 'normal' : 'italic';
                updateSelectionToolbar();
                saveStateForUndo();
            }
        }

        function updateSelectionToolbar() {
            const hasBox = selectedItems.some(item => item.type === 'box');
            const isStroke = selectedItems.length === 1 && selectedItems[0].type === 'stroke';
            const canTransform = selectedItems.length > 0;
            const canPin = selectedItems.length > 0;
            const canLayer = selectedItems.length > 0;
            const canGroup = selectedItems.length > 1;
            const canUngroup = selectedItems.length === 1 && selectedItems[0].type === 'group';
            const isSingleText = selectedItems.length === 1 && selectedItems[0].type === 'text';
            const isSingleGrid = selectedItems.length === 1 && selectedItems[0].type === 'grid';


            if (selectedItems.length > 0) {
                selectionToolbar.style.display = 'flex';
                
                textToolsContainer.style.display = isSingleText ? 'flex' : 'none';
                gridToolsContainer.style.display = isSingleGrid ? 'flex' : 'none';

                if(isSingleText) {
                    const item = selectedItems[0];
                    fontFamilySelect.value = item.fontFamily || 'Inter';
                    
                    [textAlignLeftBtn, textAlignCenterBtn, textAlignRightBtn].forEach(btn => btn.classList.remove('active'));
                    if (item.textAlign === 'left') textAlignLeftBtn.classList.add('active');
                    else if (item.textAlign === 'right') textAlignRightBtn.classList.add('active');
                    else textAlignCenterBtn.classList.add('active');

                    textStyleBoldBtn.classList.toggle('active', item.fontWeight === 'bold');
                    textStyleItalicBtn.classList.toggle('active', item.fontStyle === 'italic');
                }
                
                if (isSingleGrid) {
                    const item = selectedItems[0];
                    gridRowsInput.value = item.rows;
                    gridColsInput.value = item.cols;
                }

                toggleBoxStyleBtn.style.display = hasBox ? 'flex' : 'none';
                flipHBtn.style.display = canTransform ? 'flex' : 'none';
                flipVBtn.style.display = canTransform ? 'flex' : 'none';
                scaleBtn.style.display = canTransform ? 'flex' : 'none';
                rotateBtn.style.display = canTransform ? 'flex' : 'none';
                pinBtn.style.display = canPin ? 'flex' : 'none';
                bringFrontBtn.style.display = canLayer ? 'flex' : 'none';
                sendBackBtn.style.display = canLayer ? 'flex' : 'none';
                groupBtn.style.display = canGroup ? 'flex' : 'none';
                ungroupBtn.style.display = canUngroup ? 'flex' : 'none';
                
                scaleBtn.classList.toggle('active', activeGizmo === 'scale');
                rotateBtn.classList.toggle('active', activeGizmo === 'rotate');
                pinBtn.classList.toggle('pinned', canPin && selectedItems.every(i => i.isPinned));

                const isSingleBox = selectedItems.length === 1 && selectedItems[0].type === 'box';
                if(isSingleBox && !selectedItems[0].isPinned) {
                    boxColorPickerContainer.style.display = 'block';
                    boxColorPicker.value = selectedItems[0].color;
                } else {
                    boxColorPickerContainer.style.display = 'none';
                }

            } else { 
                selectionToolbar.style.display = 'none';
                boxColorPickerContainer.style.display = 'none';
                textToolsContainer.style.display = 'none';
                gridToolsContainer.style.display = 'none';
                activeGizmo = null; 
            }
        }

        function updateToolbarPosition() {
             if (selectedItems.length > 0) {
                const collectiveBox = getCollectiveBoundingBox(selectedItems);
                const screenPos = worldToScreen({ x: collectiveBox.x + collectiveBox.width / 2, y: collectiveBox.y + collectiveBox.height });
                selectionToolbar.style.left = `${screenPos.x}px`;
                selectionToolbar.style.top = `${screenPos.y}px`;
                
                if(selectedItems.length === 1 && selectedItems[0].type === 'box' && !selectedItems[0].isPinned){
                    const item = selectedItems[0];
                    const boxTopLeft = worldToScreen({x: item.x, y: item.y});
                    boxColorPickerContainer.style.left = `${boxTopLeft.x - 12}px`;
                    boxColorPickerContainer.style.top = `${boxTopLeft.y - 12}px`;
                }
            }
        }

        function editText(item) {
            currentlyEditingText = item;
            item.isHidden = true;
            const screenPos = worldToScreen({ x: item.x, y: item.y });
            const screenWidth = item.width * cameraZoom;
            Object.assign(textEditor.style, {
                display: 'block', left: `${screenPos.x}px`, top: `${screenPos.y}px`,
                width: `${screenWidth}px`, height: 'auto',
                transform: `rotate(${item.rotation}rad)`, transformOrigin: 'top left',
                color: accentColor, backgroundColor: hexToRgba(accentColor, 0.1),
                fontSize: `${item.fontSize * cameraZoom}px`,
                fontFamily: item.fontFamily || 'Inter',
                textAlign: item.textAlign || 'center',
                fontWeight: item.fontWeight || 'bold',
                fontStyle: item.fontStyle || 'normal',
            });
            textEditor.value = item.text === "Type..." ? "" : item.text;
            textEditor.focus();
            autoResizeTextEditor();
            selectedItems = [];
            updateToolbarPosition();
            updateLeftBarState();
        }

        function finishEditingText() {
            if (currentlyEditingText) {
                currentlyEditingText.text = textEditor.value.trim() || "Type...";
                // Recalculate width/height based on new text content
                const item = currentlyEditingText;
                const style = item.fontStyle || 'normal';
                const weight = item.fontWeight || 'bold';
                const family = item.fontFamily || 'Inter';
                ctx.font = `${style} ${weight} ${item.fontSize}px '${family}', sans-serif`;
                const lines = textEditor.value.split('\n');
                let maxWidth = 0;
                lines.forEach(line => {
                    const metrics = ctx.measureText(line);
                    if (metrics.width > maxWidth) maxWidth = metrics.width;
                });
                currentlyEditingText.width = maxWidth + 20; // Add padding
                currentlyEditingText.height = textEditor.scrollHeight / cameraZoom;

                currentlyEditingText.isHidden = false;
                selectedItems = [currentlyEditingText];
                saveStateForUndo();
                currentlyEditingText = null;
            }
            textEditor.style.display = 'none';
        }
        
        function autoResizeTextEditor() {
            textEditor.style.height = 'auto';
            textEditor.style.height = textEditor.scrollHeight + 'px';
        }

        // --- HISTORY & UNDO FUNCTIONS ---

        function saveStateForUndo() {
            const stateToSave = JSON.stringify(items, (key, value) => {
                if (key === 'img') {
                    return value.src; // Store image source instead of the object
                }
                return value;
            });

            if (historyIndex < historyStack.length - 1) {
                historyStack = historyStack.slice(0, historyIndex + 1);
            }

            if (historyStack.length > 0 && historyStack[historyStack.length - 1] === stateToSave) return;

            historyStack.push(stateToSave);
            historyIndex++;

            if (historyStack.length > HISTORY_LIMIT) {
                historyStack.shift();
                historyIndex--;
            }
        }
        
        function loadStateFromHistory(stateJson) {
            const historyState = JSON.parse(stateJson);
            selectedItems = [];
            updateSelectionToolbar();
            updateLeftBarState();

            const recreateItems = (itemList) => {
                return itemList.map(itemState => {
                    const newItem = { ...(itemState.scaleX !== undefined ? {} : { scaleX: 1, scaleY: 1 }), ...itemState };
                    if (newItem.type === 'image') {
                        const img = new Image();
                        img.src = itemState.img;
                        newItem.img = img;
                    } else if (newItem.type === 'group') {
                        newItem.items = recreateItems(newItem.items);
                    }
                    return newItem;
                });
            };
            items = recreateItems(historyState);
        }

        function undoLastAction() {
            if (historyIndex > 0) {
                historyIndex--;
                const previousStateJson = historyStack[historyIndex];
                loadStateFromHistory(previousStateJson);
            }
        }

        function redoLastAction() {
            if (historyIndex < historyStack.length - 1) {
                historyIndex++;
                const nextStateJson = historyStack[historyIndex];
                loadStateFromHistory(nextStateJson);
            }
        }

        // --- GROUPING FUNCTIONS ---

        function groupSelectedItems() {
            if (selectedItems.length <= 1) return;

            saveStateForUndo(); 

            // --- FLATTENING LOGIC ---
            // 1. Create a new, flat list of all base elements.
            const flatItemsToGroup = [];
            selectedItems.forEach(item => {
                if (item.type === 'group') {
                    // Temporarily ungroup to get absolute positions of children
                    const groupCenterX = item.x + item.width / 2;
                    const groupCenterY = item.y + item.height / 2;
                    const cosR = Math.cos(item.rotation);
                    const sinR = Math.sin(item.rotation);

                    item.items.forEach(child => {
                        const worldItem = JSON.parse(JSON.stringify(child));
                        reattachImages(child, worldItem); // Preserve the image object

                        const childCenterX_rel = child.x + child.width / 2;
                        const childCenterY_rel = child.y + child.height / 2;
                        const childCenterX_from_group_center = childCenterX_rel - item.width / 2;
                        const childCenterY_from_group_center = childCenterY_rel - item.height / 2;

                        const rotatedX = childCenterX_from_group_center * cosR - childCenterY_from_group_center * sinR;
                        const rotatedY = childCenterX_from_group_center * sinR + childCenterY_from_group_center * cosR;

                        const newWorldCenterX = groupCenterX + rotatedX;
                        const newWorldCenterY = groupCenterY + rotatedY;

                        worldItem.x = newWorldCenterX - child.width / 2;
                        worldItem.y = newWorldCenterY - child.height / 2;
                        worldItem.rotation = (child.rotation || 0) + item.rotation;

                        if (worldItem.type === 'arrow' || worldItem.type === 'stroke') {
                             const transformPoint = (p) => {
                                const childPointX_rel = child.x + p.x;
                                const childPointY_rel = child.y + p.y;
                                const px_from_center = childPointX_rel - item.width / 2;
                                const py_from_center = childPointY_rel - item.height / 2;
                                const rot_px = px_from_center * cosR - py_from_center * sinR;
                                const rot_py = px_from_center * sinR + py_from_center * cosR;
                                return { x: groupCenterX + rot_px, y: groupCenterY + rot_py };
                            };
                            if (worldItem.type === 'arrow') {
                                const newStart = transformPoint({x: child.startX - child.x, y: child.startY - child.y});
                                const newEnd = transformPoint({x: child.endX - child.x, y: child.endY - child.y});
                                worldItem.startX = newStart.x; worldItem.startY = newStart.y;
                                worldItem.endX = newEnd.x; worldItem.endY = newEnd.y;
                            } else { // stroke
                                worldItem.points = child.points.map(p => transformPoint({x: p.x - child.x, y: p.y - child.y}));
                            }
                        }
                        flatItemsToGroup.push(worldItem);
                    });
                } else {
                    flatItemsToGroup.push(item);
                }
            });

            // 2. Get the collective bounding box of all flattened items.
            const box = getCollectiveBoundingBox(flatItemsToGroup);
            
            const newGroup = {
                id: Date.now(),
                type: 'group',
                x: box.x, y: box.y,
                width: box.width, height: box.height,
                rotation: 0,
                isPinned: false,
                opacity: 1,
                scaleX: 1,
                scaleY: 1,
                items: []
            };

            // 3. Make all items relative to the new group's top-left corner.
            flatItemsToGroup.forEach(item => {
                const relativeItem = JSON.parse(JSON.stringify(item));
                reattachImages(item, relativeItem);
                
                relativeItem.x -= newGroup.x;
                relativeItem.y -= newGroup.y;

                if (relativeItem.type === 'arrow') {
                    relativeItem.startX -= newGroup.x; relativeItem.startY -= newGroup.y;
                    relativeItem.endX -= newGroup.x; relativeItem.endY -= newGroup.y;
                } else if (relativeItem.type === 'stroke') {
                    relativeItem.points.forEach(p => {
                        p.x -= newGroup.x; p.y -= newGroup.y;
                    });
                }

                newGroup.items.push(relativeItem);
            });
            
            // 4. Remove all original selected items from the main canvas.
            const idsToGroup = new Set(selectedItems.map(item => item.id));
            items = items.filter(item => !idsToGroup.has(item.id));

            // 5. Add the new, combined group.
            items.push(newGroup);
            selectedItems = [newGroup];

            updateSelectionToolbar();
            updateLeftBarState();
        }

        function ungroupSelectedItems() {
            const groupsToUngroup = selectedItems.filter(item => item.type === 'group');
            if (groupsToUngroup.length === 0) return;

            saveStateForUndo();

            const newlyUngroupedItems = [];
            const groupIdsToRemove = new Set();

            groupsToUngroup.forEach(group => {
                groupIdsToRemove.add(group.id);

                const groupCenterX = group.x + group.width / 2;
                const groupCenterY = group.y + group.height / 2;
                const cosR = Math.cos(group.rotation);
                const sinR = Math.sin(group.rotation);

                group.items.forEach(child => {
                    const newWorldItem = JSON.parse(JSON.stringify(child));

                    // Re-attach images recursively from the original child
                    reattachImages(child, newWorldItem);

                    if (newWorldItem.type === 'arrow' || newWorldItem.type === 'stroke') {
                        const transformPoint = (p) => {
                            const childPointX_rel_group_topleft = child.x + p.x;
                            const childPointY_rel_group_topleft = child.y + p.y;
                            const px_from_group_center = childPointX_rel_group_topleft - group.width / 2;
                            const py_from_group_center = childPointY_rel_group_topleft - group.height / 2;
                            const rot_px = px_from_group_center * cosR - py_from_group_center * sinR;
                            const rot_py = px_from_group_center * sinR + py_from_group_center * cosR;
                            return { x: groupCenterX + rot_px, y: groupCenterY + rot_py };
                        };
                         if (newWorldItem.type === 'arrow') {
                            const newStart = transformPoint({x: child.startX - child.x, y: child.startY - child.y});
                            const newEnd = transformPoint({x: child.endX - child.x, y: child.endY - child.y});
                            newWorldItem.startX = newStart.x; newWorldItem.startY = newStart.y;
                            newWorldItem.endX = newEnd.x; newWorldItem.endY = newEnd.y;
                        } else { // stroke
                            newWorldItem.points = child.points.map(p => transformPoint({x: p.x - child.x, y: p.y - child.y}));
                        }
                    }

                    const childCenterX_rel = child.x + child.width / 2;
                    const childCenterY_rel = child.y + child.height / 2;
                    const childCenterX_from_group_center = childCenterX_rel - group.width / 2;
                    const childCenterY_from_group_center = childCenterY_rel - group.height / 2;
                    const rotatedX = childCenterX_from_group_center * cosR - childCenterY_from_group_center * sinR;
                    const rotatedY = childCenterX_from_group_center * sinR + childCenterY_from_group_center * cosR;
                    const newWorldCenterX = groupCenterX + rotatedX;
                    const newWorldCenterY = groupCenterY + rotatedY;
                    newWorldItem.x = newWorldCenterX - child.width / 2;
                    newWorldItem.y = newWorldCenterY - child.height / 2;
                    newWorldItem.rotation = (child.rotation || 0) + group.rotation;
                    
                    items.push(newWorldItem);
                    newlyUngroupedItems.push(newWorldItem);
                });
            });

            items = items.filter(item => !groupIdsToRemove.has(item.id));
            selectedItems = newlyUngroupedItems;

            updateSelectionToolbar();
            updateLeftBarState();
        }

        // --- PALETTE FUNCTIONS ---
        function buildPaletteMenu() {
            palettePanel.innerHTML = '';
            colorPalettes.forEach(p => {
                const option = document.createElement('div');
                option.className = 'palette-option';
                option.innerHTML = `
                    <div class="palette-color" style="background-color: ${p.bg}"></div>
                    <div class="palette-color" style="background-color: ${p.accent}"></div>
                    <div class="palette-color" style="background-color: ${p.grid}"></div>
                `;
                option.addEventListener('click', () => {
                    canvasBackgroundColor = p.bg;
                    accentColor = p.accent;
                    gridColor = p.grid;
                    updateUIColors();
                    palettePanel.classList.remove('open');
                });
                palettePanel.appendChild(option);
            });
        }
        
        // --- TOAST NOTIFICATION ---

        function showToast(message, type = 'success') {
            if (!showNotifications) return;
            const container = document.getElementById('toast-container');
            if (!container) return;

            const toast = document.createElement('div');
            toast.className = `toast-notification ${type}`;
            
            let iconSvg = '';
            if (type === 'success') {
                iconSvg = `<svg xmlns="http://www.w3.org/2000/svg" class="icon" viewBox="0 0 20 20" fill="currentColor"><path fill-rule="evenodd" d="M10 18a8 8 0 100-16 8 8 0 000 16zm3.707-9.293a1 1 0 00-1.414-1.414L9 10.586 7.707 9.293a1 1 0 00-1.414 1.414l2 2a1 1 0 001.414 0l4-4z" clip-rule="evenodd" /></svg>`;
            } else if (type === 'error') {
                iconSvg = `<svg xmlns="http://www.w3.org/2000/svg" class="icon" viewBox="0 0 20 20" fill="currentColor"><path fill-rule="evenodd" d="M10 18a8 8 0 100-16 8 8 0 000 16zM8.707 7.293a1 1 0 00-1.414 1.414L8.586 10l-1.293 1.293a1 1 0 101.414 1.414L10 11.414l1.293 1.293a1 1 0 001.414-1.414L11.414 10l1.293-1.293a1 1 0 00-1.414-1.414L10 8.586 8.707 7.293z" clip-rule="evenodd" /></svg>`;
            }

            toast.innerHTML = `${iconSvg}<span>${message}</span>`;
            
            container.appendChild(toast);

            setTimeout(() => {
                toast.remove();
            }, 3000); // 3000ms total lifetime
        }
        
        // --- TOUCH HANDLING & MOBILE SUPPORT ---

        let lastTap = 0;
        let longPressTimer = null;
        let isPinching = false;
        let initialPinchDistance = null;
        let lastPinchCenter = null;
        let initialCameraZoomOnPinch = 1;

        function onTouchStart(e) {
            e.preventDefault();
            clearTimeout(longPressTimer);

            if (e.touches.length === 1 && !isPinching) {
                const now = new Date().getTime();
                const timeSinceLastTap = now - lastTap;
                
                if (timeSinceLastTap < 300 && timeSinceLastTap > 0) { // Double tap
                    onDoubleClick(normalizeTouchEvent(e));
                    lastTap = 0;
                    return;
                }
                lastTap = now;

                longPressTimer = setTimeout(() => {
                    onContextMenu({ preventDefault: () => {}, ...normalizeTouchEvent(e) });
                    if (navigator.vibrate) navigator.vibrate(50);
                }, 750);

                onMouseDown(normalizeTouchEvent(e));
            } else if (e.touches.length === 2) {
                // Entering pinch mode, cancel any single-touch actions
                isDrawing = false; isMovingItems = false; isTransforming = false; isTransformingArrow = false; isSelectingBox = false;

                isPinching = true;
                initialPinchDistance = getPinchDistance(e);
                lastPinchCenter = getPinchCenter(e);
                initialCameraZoomOnPinch = cameraZoom;
            }
        }

        function onTouchMove(e) {
            e.preventDefault();
            clearTimeout(longPressTimer);

            if (e.touches.length === 1 && !isPinching) {
                onMouseMove(normalizeTouchEvent(e));
            } else if (e.touches.length === 2 && isPinching) {
                const currentCenter = getPinchCenter(e);
                
                // --- PAN ---
                const deltaX = currentCenter.x - lastPinchCenter.x;
                const deltaY = currentCenter.y - lastPinchCenter.y;
                cameraOffset.x += deltaX / cameraZoom;
                cameraOffset.y += deltaY / cameraZoom;

                // --- ZOOM ---
                const newPinchDistance = getPinchDistance(e);
                const zoomFactor = newPinchDistance / initialPinchDistance;
                const newZoom = initialCameraZoomOnPinch * zoomFactor;
                
                const worldPosBeforeZoom = screenToWorld(currentCenter);
                cameraZoom = Math.max(MIN_ZOOM, Math.min(MAX_ZOOM, newZoom));
                const worldPosAfterZoom = screenToWorld(currentCenter);
                
                cameraOffset.x += worldPosAfterZoom.x - worldPosBeforeZoom.x;
                cameraOffset.y += worldPosAfterZoom.y - worldPosBeforeZoom.y;

                lastPinchCenter = currentCenter;
            }
        }

        function onTouchEnd(e) {
            e.preventDefault();
            clearTimeout(longPressTimer);

            if (e.touches.length < 2) {
                isPinching = false;
                initialPinchDistance = null;
                lastPinchCenter = null;
            }

            // onMouseUp handles resetting isMovingItems etc.
            if (e.touches.length === 0) {
                 onMouseUp(normalizeTouchEvent(e));
            }
        }

        function getPinchDistance(e) {
            const t1 = e.touches[0];
            const t2 = e.touches[1];
            return Math.hypot(t1.clientX - t2.clientX, t1.clientY - t2.clientY);
        }

        function getPinchCenter(e) {
            const t1 = e.touches[0];
            const t2 = e.touches[1];
            return { x: (t1.clientX + t2.clientX) / 2, y: (t1.clientY + t2.clientY) / 2 };
        }

        function normalizeTouchEvent(e) {
            let touch;
            if (e.touches && e.touches.length > 0) {
                touch = e.touches[0];
            } else if (e.changedTouches && e.changedTouches.length > 0) {
                touch = e.changedTouches[0];
            } else {
                 return { clientX: 0, clientY: 0, button: 0, target: e.target };
            }
            return { clientX: touch.clientX, clientY: touch.clientY, button: 0, target: e.target };
        }

        // --- UTILITY FUNCTIONS ---
        
        function getEventLocation(e) { return { x: e.clientX, y: e.clientY }; }
        function screenToWorld(p) { return { x: (p.x - canvas.width / 2) / cameraZoom - cameraOffset.x + canvas.width / 2, y: (p.y - canvas.height / 2) / cameraZoom - cameraOffset.y + canvas.height / 2 }; }
        function worldToScreen(p) { return { x: (p.x + cameraOffset.x - canvas.width / 2) * cameraZoom + canvas.width / 2, y: (p.y + cameraOffset.y - canvas.height / 2) * cameraZoom + canvas.height / 2 }; }
        
        // Recursively re-attaches HTMLImageElement objects after a JSON clone
        function reattachImages(sourceItem, targetItem) {
            if (!sourceItem || !targetItem) return;

            if (sourceItem.type === 'image' && sourceItem.img instanceof HTMLImageElement) {
                targetItem.img = sourceItem.img;
            } else if (sourceItem.type === 'group') {
                if (sourceItem.items && targetItem.items) {
                    sourceItem.items.forEach((childSource, index) => {
                        reattachImages(childSource, targetItem.items[index]);
                    });
                }
            }
        }

        function getItemAtPosition(pos) {
             for (let i = items.length - 1; i >= 0; i--) {
                const item = items[i];
                const box = getItemBoundingBox(item);
                if (pos.x >= box.x && pos.x <= box.x + box.width && pos.y >= box.y && pos.y <= box.y + box.height) {
                    if (item.type === 'group') {
                        // Transform the click position into the group's local, unrotated space
                        const groupCenterX = item.x + item.width / 2;
                        const groupCenterY = item.y + item.height / 2;
                        const dx = pos.x - groupCenterX;
                        const dy = pos.y - groupCenterY;
                        const cos = Math.cos(-item.rotation);
                        const sin = Math.sin(-item.rotation);
                        const rotatedX = dx * cos - dy * sin;
                        const rotatedY = dx * sin + dy * cos;
                        const localClickX = rotatedX + groupCenterX - item.x;
                        const localClickY = rotatedY + groupCenterY - item.y;
                        
                        // Check children recursively (we can just check one level for now)
                        for (let j = item.items.length - 1; j >= 0; j--) {
                            const child = item.items[j];
                             const childBox = {x: child.x, y: child.y, width: child.width, height: child.height}; //getItemBoundingBox(child) is overkill here
                            if(localClickX >= childBox.x && localClickX <= childBox.x + childBox.width && localClickY >= childBox.y && localClickY <= childBox.y + childBox.height){
                                return item; // If a child is hit, return the parent group
                            }
                        }
                    }

                    if (item.type === 'stroke') {
                        for (let j = 0; j < item.points.length - 1; j++) {
                            if (Math.sqrt(distToSegmentSquared(pos, item.points[j], item.points[j+1])) < 10 / cameraZoom) return item;
                        }
                    } else if (item.type === 'arrow') {
                        if (Math.sqrt(distToSegmentSquared(pos, {x: item.startX, y: item.startY}, {x: item.endX, y: item.endY})) < 10 / cameraZoom) return item;
                    } else { 
                        const centerX = item.x + item.width / 2, centerY = item.y + item.height / 2;
                        const dx = pos.x - centerX, dy = pos.y - centerY, angle = -item.rotation;
                        const rotatedX = dx * Math.cos(angle) - dy * Math.sin(angle);
                        const rotatedY = dx * Math.sin(angle) + dy * Math.cos(angle);
                        if (rotatedX > -item.width / 2 && rotatedX < item.width / 2 && rotatedY > -item.height / 2 && rotatedY < item.height / 2) return item;
                    }
                }
            }
            return null;
        }

        function getGizmoAtPosition(worldPos) {
            if (selectedItems.length !== 1 || !activeGizmo) return null;
            const item = selectedItems[0];
            if (item.isPinned || item.type === 'arrow' || item.type === 'stroke') return null;
            
            const handleSize = 14 / cameraZoom, centerX = item.x + item.width / 2, centerY = item.y + item.height / 2;
            if (activeGizmo === 'rotate') {
                const rotDX = item.width / 2, rotDY = -item.height / 2 - 20 / cameraZoom;
                const rotX = rotDX * Math.cos(item.rotation) - rotDY * Math.sin(item.rotation);
                const rotY = rotDX * Math.sin(item.rotation) + rotDY * Math.cos(item.rotation);
                if (Math.hypot(worldPos.x - (centerX + rotX), worldPos.y - (centerY + rotY)) < handleSize) return 'rotate';
            } else if (activeGizmo === 'scale') {
                const scaleDX = item.width / 2, scaleDY = item.height / 2;
                const scaleX = scaleDX * Math.cos(item.rotation) - scaleDY * Math.sin(item.rotation);
                const scaleY = scaleDX * Math.sin(item.rotation) + scaleDY * Math.cos(item.rotation);
                if (Math.hypot(worldPos.x - (centerX + scaleX), worldPos.y - (centerY + scaleY)) < handleSize) return 'scale';
            }
            return null;
        }

        function getArrowHandleAtPosition(worldPos) {
            if (selectedItems.length !== 1) return null;
            const item = selectedItems[0];
            if (item.isPinned || item.type !== 'arrow') return null;
            const handleRadius = 12 / cameraZoom;
            if (Math.hypot(worldPos.x - item.startX, worldPos.y - item.startY) < handleRadius) return 'start';
            if (Math.hypot(worldPos.x - item.endX, worldPos.y - item.endY) < handleRadius) return 'end';
            return null;
        }

        function getCollectiveBoundingBox(itemList) {
            if (itemList.length === 0) return { x: 0, y: 0, width: 0, height: 0 };
            let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
            itemList.forEach(item => {
                const box = getItemBoundingBox(item);
                minX = Math.min(minX, box.x);
                minY = Math.min(minY, box.y);
                maxX = Math.max(maxX, box.x + box.width);
                maxY = Math.max(maxY, box.y + box.height);
            });
            return { x: minX, y: minY, width: maxX - minX, height: maxY - minY };
        }

        function getItemBoundingBox(item) {
             if (item.type === 'group') {
                if (!item.items || item.items.length === 0) {
                    return { x: item.x, y: item.y, width: item.width, height: item.height };
                }
                // Calculate bounding box based on children's transformed positions
                let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
                
                const groupCenterX = item.x + item.width / 2;
                const groupCenterY = item.y + item.height / 2;
                const cosR = Math.cos(item.rotation);
                const sinR = Math.sin(item.rotation);

                item.items.forEach(child => {
                    const childBox = getItemBoundingBox(child);
                    const childCorners = [
                        {x: childBox.x, y: childBox.y},
                        {x: childBox.x + childBox.width, y: childBox.y},
                        {x: childBox.x + childBox.width, y: childBox.y + childBox.height},
                        {x: childBox.x, y: childBox.y + childBox.height},
                    ];

                    childCorners.forEach(corner => {
                        // The corner is relative to the child's own origin, which is relative to the group's origin
                        const cornerX_rel_group = corner.x;
                        const cornerY_rel_group = corner.y;

                        // Position relative to group center
                        const px_from_center = (item.x + cornerX_rel_group) - groupCenterX;
                        const py_from_center = (item.y + cornerY_rel_group) - groupCenterY;

                        // Rotate
                        const rot_px = px_from_center * cosR - py_from_center * sinR;
                        const rot_py = px_from_center * sinR + py_from_center * cosR;

                        const finalX = groupCenterX + rot_px;
                        const finalY = groupCenterY + rot_py;

                        minX = Math.min(minX, finalX);
                        minY = Math.min(minY, finalY);
                        maxX = Math.max(maxX, finalX);
                        maxY = Math.max(maxY, finalY);
                    });
                });
                return { x: minX, y: minY, width: maxX - minX, height: maxY - minY };
             }
            if (item.type === 'stroke') {
                let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
                if (item.points && item.points.length > 0) {
                    item.points.forEach(p => {
                        minX = Math.min(minX, p.x);
                        minY = Math.min(minY, p.y);
                        maxX = Math.max(maxX, p.x);
                        maxY = Math.max(maxY, p.y);
                    });
                    return { x: minX, y: minY, width: maxX - minX, height: maxY - minY };
                }
                 return { x: item.x, y: item.y, width: 0, height: 0 };
            }
            if (item.type === 'arrow') {
                return { x: Math.min(item.startX, item.endX), y: Math.min(item.startY, item.endY), width: Math.abs(item.startX - item.endX), height: Math.abs(item.startY - item.endY) };
            }
            const w = item.width, h = item.height, cx = item.x + w / 2, cy = item.y + h / 2, angle = item.rotation;
            const cos = Math.cos(angle), sin = Math.sin(angle);
            let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
            [{x:-w/2,y:-h/2},{x:w/2,y:-h/2},{x:w/2,y:h/2},{x:-w/2,y:h/2}].forEach(c => {
                const rotX = c.x * cos - c.y * sin + cx, rotY = c.x * sin + c.y * cos + cy;
                minX = Math.min(minX, rotX); minY = Math.min(minY, rotY);
                maxX = Math.max(maxX, rotX); maxY = Math.max(maxY, rotY);
            });
            return { x: minX, y: minY, width: maxX - minX, height: maxY - minY };
        }
        function rectsIntersect(r1, r2) { return !(r2.x > r1.x + r1.width || r2.x + r2.width < r1.x || r2.y > r1.y + r1.height || r2.y + r2.height < r1.y); }
        function getNormalizedSelectionBox() { return { x: Math.min(selectionBox.startX, selectionBox.endX), y: Math.min(selectionBox.startY, selectionBox.endY), width: Math.abs(selectionBox.startX - selectionBox.endX), height: Math.abs(selectionBox.startY - selectionBox.endY) }; }
        function hexToRgba(hex, alpha) {
            let r=0,g=0,b=0;
            if(hex.length==4){r="0x"+hex[1]+hex[1];g="0x"+hex[2]+hex[2];b="0x"+hex[3]+hex[3];}else if(hex.length==7){r="0x"+hex[1]+hex[2];g="0x"+hex[3]+hex[4];b="0x"+hex[5]+hex[6];}
            return`rgba(${+r},${+g},${+b},${alpha})`;
        }
        function rgbToHex(r, g, b) {
            return "#" + ((1 << 24) + (r << 16) + (g << 8) + b).toString(16).slice(1);
        }
        function distSq(p1,p2){return Math.pow(p1.x-p2.x,2)+Math.pow(p1.y-p2.y,2);}
        function distToSegmentSquared(p,v,w){
            const l2=distSq(v,w); if(l2===0)return distSq(p,v);
            let t=((p.x-v.x)*(w.x-v.x)+(p.y-v.y)*(w.y-v.y))/l2;
            t=Math.max(0,Math.min(1,t));
            return distSq(p,{x:v.x+t*(w.x-v.x),y:v.y+t*(w.y-v.y)});
        }
        function invertColor(hex){
            if(hex.indexOf('#')===0)hex=hex.slice(1); if(hex.length===3)hex=hex[0]+hex[0]+hex[1]+hex[1]+hex[2]+hex[2];
            if(hex.length!==6)return'#ffffff';
            const r=(255-parseInt(hex.slice(0,2),16)).toString(16),g=(255-parseInt(hex.slice(2,4),16)).toString(16),b=(255-parseInt(hex.slice(4,6),16)).toString(16);
            return'#'+padZero(r)+padZero(g)+padZero(b);
        }
        function hslToRgb(h,s,l){let c=(1-Math.abs(2*l-1))*s,x=c*(1-Math.abs((h/60)%2-1)),m=l-c/2,r=0,g=0,b=0;if(0<=h&&h<60){r=c;g=x;b=0;}else if(60<=h&&h<120){r=x;g=c;b=0;}else if(120<=h&&h<180){r=0;g=c;b=x;}else if(180<=h&&h<240){r=0;g=x;b=c;}else if(240<=h&&h<300){r=x;g=0;b=c;}else if(300<=h&&h<360){r=c;g=0;b=x;}return[Math.round((r+m)*255),Math.round((g+m)*255),Math.round((b+m)*255)];}
        function hexToHsl(H){let r=0,g=0,b=0;if(H.length==4){r="0x"+H[1]+H[1];g="0x"+H[2]+H[2];b="0x"+H[3]+H[3];}else if(H.length==7){r="0x"+H[1]+H[2];g="0x"+H[3]+H[4];b="0x"+H[5]+hex[6];}r/=255;g/=255;b/=255;let cmin=Math.min(r,g,b),cmax=Math.max(r,g,b),delta=cmax-cmin,h=0,s=0,l=0;if(delta==0)h=0;else if(cmax==r)h=((g-b)/delta)%6;else if(cmax==g)h=(b-r)/delta+2;else h=(r-g)/delta+4;h=Math.round(h*60);if(h<0)h+=360;l=(cmax+cmin)/2;s=delta==0?0:delta/(1-Math.abs(2*l-1));return[h,s,l];}
        function hslToHex(h,s,l){let c=(1-Math.abs(2*l-1))*s,x=c*(1-Math.abs((h/60)%2-1)),m=l-c/2,r=0,g=0,b=0;if(0<=h&&h<60){r=c;g=x;b=0;}else if(60<=h&&h<120){r=x;g=c;b=0;}else if(180<=h&&h<180){r=0;g=c;b=x;}else if(180<=h&&h<240){r=0;g=x;b=c;}else if(240<=h&&h<300){r=x;g=0;b=c;}else if(300<=h&&h<360){r=c;g=0;b=x;}r=Math.round((r+m)*255).toString(16);g=Math.round((g+m)*255).toString(16);b=Math.round((b+m)*255).toString(16);if(r.length==1)r="0"+r;if(g.length==1)g="0"+g;if(b.length==1)b="0"+b;return"#"+r+g+b;}
        function padZero(str,len){len=len||2;const zeros=new Array(len+1).join('0');return(zeros+str).slice(-len);}
        function adjustZoom(e,z){
            if(isDragging)return;
            const wpb=screenToWorld(getEventLocation(e));
            cameraZoom = Math.max(MIN_ZOOM, Math.min(MAX_ZOOM, cameraZoom * (1 + z)));
            const wpa=screenToWorld(getEventLocation(e));
            cameraOffset.x+=wpa.x-wpb.x;cameraOffset.y+=wpa.y-wpb.y;
        }

        // --- INITIALIZATION ---
        
        // Set initial camera position to center the view
        cameraOffset = { x: window.innerWidth / 2, y: window.innerHeight / 2 };
        resizeCanvas();
        setupEventListeners();
        buildPaletteMenu();
        updateUIColors();
        projectNameInput.value = currentProjectName;
        saveStateForUndo(); // Save the initial empty state
        gameLoop();
    </script>
</body>
</html>

